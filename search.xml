<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1613</title>
    <url>/1613/</url>
    <content><![CDATA[<p>P1613 跑路 一道小绿题<br>虽然这只是一道小绿题但是我觉得还是有必要总结一下的因为不错</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有辆很 n i u b i 的汽车一秒钟可以跑2的任意整次方的距离<br>给你一个有向图问：从1跑到n最短时间（边权都是1）</p>
<h1 id="先给一会思考一下"><a href="#先给一会思考一下" class="headerlink" title="先给一会思考一下"></a>先给一会思考一下</h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，题目描述就让我们很容易想到倍增这个算法<br>我们需要把所有的边都存起来<br>但是一个问题是，在有向图上倍增……会炸……<br>很容易想到如果我们进行倍增，图并不支持随机访问（不是树）显然要一个一个跳，一定会炸<br>所以：一个dp的思路就出来了（严格意义上的dp，但不严格意义上我一般不把他算作dp）<br>就是<strong>floyd</strong><br>我们考虑倍增的思想：如果我从p点走2^n-1 到另一个点，再从另一个点走2^n-1 可以走到q点，那就说明我们可以p-&gt;q走2^n距离（就是1秒）<br>那么，我们再运用floyd的思路，如果j到i，i到k都是1秒，那么j到k就是1秒<br>我们只需要再floyd的三重循环外面加一个循环对倍增的那一维进行判断就可以了<br>floyd之后：<br>我们已经求出了那个点到那个点是1的距离，但显然我们可能不会起点到终点一定是1s<br>所以我们需要跑最短路<br>在floyd求得dis数组的基础上，跑一遍最短路，就是最后的最短时间</p>
<h1 id="代码时间"><a href="#代码时间" class="headerlink" title="代码时间"></a>代码时间</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 70</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        f[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dis[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= <span class="number">64</span>; u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (f[j][i][u - <span class="number">1</span>] &amp;&amp; f[i][k][u - <span class="number">1</span>])</span><br><span class="line">                        f[j][k][u] = <span class="number">1</span>,</span><br><span class="line">                        dis[j][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                dis[j][k] = <span class="built_in">min</span>(dis[j][k], dis[j][i] + dis[i][k]);</span><br><span class="line">    cout &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒花<br>还蛮有意思的一道题……</p>
]]></content>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA</title>
    <url>/LCA/</url>
    <content><![CDATA[<h1 id="最近公共祖先LCA-洛谷P3379"><a href="#最近公共祖先LCA-洛谷P3379" class="headerlink" title="最近公共祖先LCA 洛谷P3379"></a>最近公共祖先LCA 洛谷P3379</h1><h2 id="今天xiao习了一下LCA过程十分曲折。。。"><a href="#今天xiao习了一下LCA过程十分曲折。。。" class="headerlink" title="今天xiao习了一下LCA过程十分曲折。。。"></a>今天xiao习了一下LCA过程十分曲折。。。</h2><p>（检查的时候主函数没有调用dfs，调试了好几遍才发现。。。<br>首先，我们先来看一看定义：最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。<br>它有三种做法：</p>
<ol>
<li>暴力 </li>
<li>倍增 </li>
<li>树链剖分<br>遗憾的是我就会前两种；<h2 id="第一种枚举"><a href="#第一种枚举" class="headerlink" title="第一种枚举"></a>第一种枚举</h2>我们有了这么一棵树，和其中的两个节点；那么我们只需要一个一个求出它们的祖先，一步步向上跳就可以找到交点，找到第一个交点就是最近公共祖先<br>显而易见，这是最为朴素的正解；<br>但不是最优解；<br>仔细一想就知道他可顶复杂度超高（给两个叶子结点最后回到根上）<br>明显过不去<br>那么就要想方设法优化<h2 id="第二种方法-倍增"><a href="#第二种方法-倍增" class="headerlink" title="第二种方法 倍增"></a>第二种方法 倍增</h2>倍增求LCA是最经典的方法了（不要问我谁提出来的问就是不知道）<br>上面朴素做法是一步一步向上跳，那么我们就可以很多步很多步向上跳，就可以优化；<br>而倍增就是优化的方法之一，以logn的时间复杂度来向上查询<br>只需要预处理出一个数组f[u][i]u是节点，i是指u向上2^i个节点处（第2^i个祖先<br>那么我们就可以一步一步向上跳<h2 id="第三种方法-树链剖分"><a href="#第三种方法-树链剖分" class="headerlink" title="第三种方法 树链剖分"></a>第三种方法 树链剖分</h2>我不会。。。……以后再写<h2 id="上代码："><a href="#上代码：" class="headerlink" title="上代码："></a>上代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> next,v;</span><br><span class="line">&#125;cun[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],d[maxn],f[maxn][<span class="number">22</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cun[++tot].next=head[x];head[x]=tot;cun[tot].v=y;<span class="comment">//结构体存链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=d[fa]+<span class="number">1</span>;<span class="comment">//子节点深度是父节点加一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[u][i+<span class="number">1</span>]=f[f[u][i]][i];<span class="comment">//可以自己推导（就是乘个二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=cun[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=cun[i].v;<span class="comment">//邻接表向后查询</span></span><br><span class="line">        <span class="keyword">if</span>(a==fa)<span class="keyword">continue</span>;<span class="comment">//不查询父节点</span></span><br><span class="line">        f[a][<span class="number">0</span>]=u;<span class="comment">//a是u的子节点，向上跳2^0是父节点u</span></span><br><span class="line">        <span class="built_in">dfs</span>(a,u);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);<span class="comment">//后面方便</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从后向前找，二进制拆分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];<span class="comment">//如果深度大就向上跳到相等为止</span></span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;<span class="comment">//如果同一深度时相等就相当于y是x的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])<span class="comment">//向上跳不相等的话就向上跳</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];y=f[y][i];<span class="comment">//继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*由于向上跳容易误判，所以我们选择向上跳到同一父节点时停止，最后输出父节点</span></span><br><span class="line"><span class="comment">        向上跳无论如何都相等时就是同一父节点了*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];<span class="comment">//父节点便是LCA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        <span class="built_in">add</span>(x1,y1);</span><br><span class="line">        <span class="built_in">add</span>(y1,x1);<span class="comment">//无向图需要双向添加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">LCA</span>(x1,y1)&lt;&lt;endl;<span class="comment">//直接输出返回的就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾声-Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q"><a href="#尾声-Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q" class="headerlink" title="尾声 Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q"></a>尾声 Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q</h2></li>
</ol>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>MST</title>
    <url>/MST/</url>
    <content><![CDATA[<h1 id="MST-最小生成树板子"><a href="#MST-最小生成树板子" class="headerlink" title="MST 最小生成树板子"></a>MST 最小生成树板子</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天对我的图论知识进行了一次的扩充，最小生成树<br>前言知识：并查集，可以去翻我的博客虽然还不完善但也有一点点的用途</p>
<h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>kruskal算法由kruskal发明（废话），本质思想是在两个最小联通块之间找到最小的边使得这两联通快之间合并代价最小（就是边权<br>所以，kruskal算法是一个贪心的做法<br>我们按照最小的边权一个一个加入，只要加入不产生环，就把这个点和这个边放进一个点集里<br>所以，不产生环。。。怎么做呢。。。<br>并查集咯。<br>很简单，再加入一条边的时候，就相当联通两个联通块，如果这两个联通块本来就是联合的，加入就会构成一个环<br>所以只要并查集查找这条边的两个点是不是已经被联通的了就好了<br>证明就是一个环中删掉最大的边的意思（差不多。。。可以去看OIWIKI<br><a href="https://oi-wiki.org/graph/mst/">https://oi-wiki.org/graph/mst/</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>P3366</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;bian[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mm p,mm q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.z&lt;q.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[p]==p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">find</span>(p);q=<span class="built_in">find</span>(q);</span><br><span class="line">    fa[p]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;bian[i].x&gt;&gt;bian[i].y&gt;&gt;bian[i].z;</span><br><span class="line">    <span class="built_in">sort</span>(bian+<span class="number">1</span>,bian+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(bian[i].x)!=<span class="built_in">find</span>(bian[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=bian[i].z;</span><br><span class="line">            <span class="built_in">merge</span>(bian[i].x,bian[i].y);</span><br><span class="line">            <span class="keyword">if</span>(++num==n<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prim算法："><a href="#prim算法：" class="headerlink" title="prim算法："></a>prim算法：</h2><p>由于本人不是很会写prim，经常写的是kruskal。。。所以就不给放程序这种东西了。。。不过一些思路我还是会的<br>prim算法和kruskal异曲同工，不过，prim算法不是加边，而是加点<br>prim算法也是维护一个连通块<br>每次加进去一个距离自己最近的点，加入自己，在更新所有点的距离（重新更新<br>就像是dijkstra。。。每次找一个最近的去更新其他的节点距离<br>所以。。。它也能堆优化<br>不过就算是堆优化也没有kruskal跑的快<br>所以 建议使用kruskal</p>
<h2 id="最小生成树的延伸————次小生成树"><a href="#最小生成树的延伸————次小生成树" class="headerlink" title="最小生成树的延伸————次小生成树"></a>最小生成树的延伸————次小生成树</h2><p>次小生成树分为两种：不过差不多就是能不能等于<br>1.非严格次小生成树<br>边权和大于等于最小生成树</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/Tree/</url>
    <content><![CDATA[<h1 id="Tree-洛谷-P2619"><a href="#Tree-洛谷-P2619" class="headerlink" title="Tree 洛谷 P2619"></a>Tree 洛谷 P2619</h1><p>一道生成树的很好的题目</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。<br>乍一看还是很没有头绪的（反正刚开始我没有</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于我们需要求一个最小权的，恰好有need条边的生成树<br>首先可以想到一个贪心的作法就是我先把最小的白边加入生成树之中直到need条跑MST<br>再把黑边跑MST加入生成树中<br>但显然。。。这个贪心的策略非常不对。。。<br>因为白边的长度和加上黑边的长度和才会是总长度和，如果黑边要加入2条边，共有三条边，为1,2,99999……黑边是会影响到白边的选取的，所以我们需要从整体上考虑问题，考虑同时加入白边黑边的时候应该如何进行选取最优<br>那我们先跑一遍MST，求出加入的白边的个数此时加入的百变个数与need一定是有差别的（如果等于了直接输出就可以了）<br>我们想要从整体上考虑问题，那么我们就改变MST的过程就好了<br>但是怎么改变就是一个问题……<br>kruskar的过程是要进行排序的，那我们就……改变权值就可以了呀！<br>我们将白边的权值进行改变，在每次与need不相符的时候就进行一次改变权值，就可以进行对百变加入生成树的过程的改变<br>如果我们将白边的权值增大以至于最小的可以加入的次小黑边，就将那条黑边加入，把这条黑边弹出，这样我们是可以获得最小的取出一条白边的代价的（因为需要一点点增加）<br>所以正解思路就具备了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现过程中，我们将白边的权值一点点的改变……<br>聪明的同学就想到了：<br>复杂度可能有点不对（然后开始diss我）<br>不要着急。。。题目中给定的边权是小于等于100的，我们进行二分就可以了呀<br>二分答案是一个很好的东西（虽然在这道题中不二分似乎也可以过去，我没有试验过，但是数据范围改一改就可以看到二分答案的优势了）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（由于是过了好长时间才回来写的博客所以有点生疏了）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> v,e,need;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,val,c;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a1,node a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a1.val==a2.val)<span class="keyword">return</span> a1.c&lt;a2.c;<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">return</span> a1.val&lt;a2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,check;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;check=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v+<span class="number">1</span>;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+e,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;cnt!=v<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aa=<span class="built_in">find</span>(a[i].u),bb=<span class="built_in">find</span>(a[i].v);</span><br><span class="line">        <span class="keyword">if</span>(aa!=bb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].c==<span class="number">0</span>)check++;<span class="comment">//白边</span></span><br><span class="line">            <span class="built_in">merge</span>(aa,bb);</span><br><span class="line">            ans+=a[i].val;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kruskal判断这一次进行MST后生成树的白边数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;e&gt;&gt;need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].val&gt;&gt;a[i].c;</span><br><span class="line">        a[i].u++;a[i].v++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">-105</span>,r=<span class="number">105</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val+=mid;</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">        <span class="keyword">if</span>(check&gt;=need)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">            num=ans-need*mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val-=mid;</span><br><span class="line">        <span class="comment">//对要加的长度进行二分答案，最后的结果再减去白边所加上的权值和</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>app</title>
    <url>/app/</url>
    <content><![CDATA[<h1 id="我的第一篇博客ohhhhhh"><a href="#我的第一篇博客ohhhhhh" class="headerlink" title="我的第一篇博客ohhhhhh"></a>我的第一篇博客ohhhhhh</h1><p>今天cloudysky帮助了无助的森森创建了自己的博客；<br>当前的森森还是个小蒟蒻；<br>但是森森相信自己在不久后的将来；<br>会变成一个大蒟蒻而爆零；<br>凡王之血必以剑终；<br>以贱民之血染红白银的御座。<br>路明非啊路明非，就你荒废的那些时间，红军长征都走到苏联去了。<br>以前我也耸着肩膀缩着头，站在别人都不看我的角落里……那样没用的，不会让你觉得更好。就算在最难的时候，也要摆出一副我是开迈巴赫来的表情啊！<br>如果一个人心里藏了那么多的喜怒哀乐，一定曾经活得伤痕累累。<br>他想自己在她眼里出现的时候,璀璨如星辰。可即使有那么一天,他披挂着漫天的星辰归来,可是仰望天空的瞳孔已经不在,看星星的女孩已经走了,那璀璨又有什么意思呢?孤单得连星星也想坠落。<br>知道了吗，没有权与力你什么都不是，你本应是一个咆哮于世间的怪物，却甘愿收起爪牙当个废物          ——路明泽；<br>goodbye,johnsonloy l o y；</p>
]]></content>
      <tags>
        <tag>first-blog</tag>
      </tags>
  </entry>
  <entry>
    <title>P1827</title>
    <url>/shu/</url>
    <content><![CDATA[<h1 id="P1827-奶牛"><a href="#P1827-奶牛" class="headerlink" title="P1827 奶牛"></a>P1827 <strong>奶牛</strong></h1><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a><strong>题目解读</strong></h2><p>其实说到底就是一道树的后序遍历反推而已嘛<br>首先，让我们看一遍题目：<br>给了一棵树的前序中序遍历，让求出后序遍历；（习惯性的打出分号<br><a href="https://oi-wiki.org/graph/tree-basic/#_14%EF%BC%88%E9%99%84%E4%B8%8AOI-WIKI%E7%9A%84%E8%AE%B2%E8%A7%A3">https://oi-wiki.org/graph/tree-basic/#_14（附上OI-WIKI的讲解</a><br>首先我们知道前序遍历在开头是根节点，那么，就将根节点取出（用string可做到<br>那么，在中序遍历中找到根节点的位置，左边就是左子树，右边就是右子树<br>在左子树中，前序遍历的<strong>左半截</strong>的开头就是左子树的根节点，再将根节点取出，再在中序遍历的<strong>左半边</strong>寻找……<br>然后再在右子树中重新做一遍这个过程，<em>（注意）</em>重新做的时候也要从左子树开始做<br>！！！这是什么！！！<br>赤裸裸的递归啊<br>所以！就可以用一个递归小函数来解决这个问题</p>
<h2 id="另一件事情"><a href="#另一件事情" class="headerlink" title="** 另一件事情 **"></a>** 另一件事情 **</h2><p>在上述说明中呢，看上去非常的简单；<br>但是，上面提到了前序遍历的左半边，难道是说要在存一个string做吗；<br>是的，需要————<br>但是不要惊慌<br>接下来我要说的就是string的库函数之一：substr()；<br>substr(本质上是复制字符串的一部分放入新的字符串之中；<br>就省得孩子们一遍遍的for了</p>
<h2 id="上代码："><a href="#上代码：" class="headerlink" title="** 上代码：**"></a>** 上代码：**</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string aa,string bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa.<span class="built_in">empty</span>())<span class="keyword">return</span>;       <span class="comment">//这是在判断边界</span></span><br><span class="line">    <span class="keyword">char</span> root=aa[<span class="number">0</span>];        <span class="comment">//将前序遍历的根节点取出来</span></span><br><span class="line">    <span class="keyword">int</span> k=bb.<span class="built_in">find</span>(root);        <span class="comment">//找到根节点</span></span><br><span class="line">    aa.<span class="built_in">erase</span>(aa.<span class="built_in">begin</span>());       <span class="comment">//将根节点从string中删除</span></span><br><span class="line">    string laa=aa.<span class="built_in">substr</span>(<span class="number">0</span>,k),raa=aa.<span class="built_in">substr</span>(k),lbb=bb.<span class="built_in">substr</span>(<span class="number">0</span>,k),rbb=bb.<span class="built_in">substr</span>(k+<span class="number">1</span>);       <span class="comment">//激动人心的拆卸时间</span></span><br><span class="line">    <span class="built_in">dfs</span>(laa,lbb);<span class="built_in">dfs</span>(raa,rbb);      <span class="comment">//遍历</span></span><br><span class="line">    cout&lt;&lt;root；         <span class="comment">//由于是后序遍历所以最后输出根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">dfs</span>(b,a);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a><strong>尾声</strong></h2><p>森森的第一篇学术博客结束</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天根据书上的指引，想要学习最小生成树，然而蒟蒻在OI WIKI上学习的时候被告知：<br>前置章节是并查集。。。<br>于是蒟蒻便用了一天的时间A了三道黄题一道蓝题（其实相当于一道黄题……<br>所以今天蒟蒻过来总结一番</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集是一种树形结构，通过名字我们可以知道：<br>并：合并，查：查询，集：集合<br>就是合并和查询一个集合<br>也可以相当于是联通块之间的判断。<br>我们把一个联通快之间的点放入一个点集之中，<br>并查集就可以查询这个点是不是在集合中（不知道集合的去预（复）习高一课本</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们看一个故事：<br>几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。<br>（来自于OI WIKI）<br>我们的并查集就相当于是这个故事中的实现过程：<br>建立一棵树，将父亲自己的儿子放进儿子节点中<br>每次询问两个人是在哪一个家族（树）之中，就询问自己的父亲是否在家族（树）之中<br>如果两个人的某个祖先（c++意义上）相等，就相当于他们两个是在一个家族中的<br>但是，有一次，两个祖先对话，想将各自的家族合并到一起，这该怎么办。。。<br>好办！将一个祖先的爸爸改成另一个祖先就可以了，反正我们不在乎某一个节点的爸爸究竟是谁，显然我们只在乎两个人是否是同一个家族也就是需不需要去一(de)起(guo)祭(gu)拜(ke)。</p>
<h2 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h2><p>查找：<br>就像上述操作一样，建立一棵树，将某些儿子们放进并查集，访问就可以知道是那颗树<br>合并：<br>也像上面一样，改父亲<br>在最开始的时候，我们是不知道谁是谁的爸爸的，那么就让他们每一个人都是一个小家族，当我们知道了谁是谁的爸爸之后，进行一次合并操作，就可以让两个人变成同一个祖先<br>但是，如果每一次查找都要向上跳到最上面的祖先或者每一次合并都需要合并n/2个点，那么复杂度将会是巨大的。。。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩，顾名思义，就是将并查集查询的路径进行压缩<br>我们上面说到了，每一次查找都需要向上进行跳跃，一直跳到祖先一样（其实一般都需要直接爬到最上面<br>这样的复杂度真的很大<br>定义中说的是：我们要判断联通块，那么我们就把所有的儿子节点直接连向树根<br>之后再去判断就只需要O（1）时间查询祖先了（虽然在预处理的时候不是O1但也快了不少</p>
<h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>说实话我不知道为什么要去这个名字，感觉很难受并且我找不到名字和操作之中的关系<br>上面有说到，我们在合并的时候，是要将一个祖先改成另一个祖先的儿子的<br>那么如果n个点，n-1个点是一个集合，1个点是一个集合，我们将它合并，要把n-1个点的爸爸都改一改，会很累<br>但如果我们把1个点的祖先更改，就会很简单的呢！（假装很厉害的样子<br>所以，每一次我们进行合并之前，都记录一下联通块的点数<br>每一次合并取一次min，就会优化</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>其实启发式合并有没有无所谓，有的时候还可能增加你的时间复杂度（其实可能就是一个常数<br>在不用启发式合并只用路径压缩的复杂度其实也就是mlogn甚至说ma(m,n)。。。<br>（所以我不会写启发式合并</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码就以洛谷的板子了P3367</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="comment">//父节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;<span class="comment">//祖先的更改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="comment">//初始化，自己是一个小家族</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionset</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))cout&lt;&lt;<span class="string">&#x27;Y&#x27;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&#x27;N&#x27;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常的简单。。。<br>我反正是这么觉得的。。。<br>时间复杂度：<a href="https://oi-wiki.org/ds/dsu-complexity/">https://oi-wiki.org/ds/dsu-complexity/</a></p>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>其实带权并查集和普通的并查集没有什么太大的不同，只是在我们每一次改变权值的时候都改一下到根节点的距离罢了<br>（其实我也不会，明天学会再改博客）</p>
<h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><p>（不会，以后再说。。。）<br>（这种东西应该是要在以后重新发博客的。。。如果你以后在我的博客之中翻到了。。。就不要让我回来改博客了。。。很累的。。。）</p>
<h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>NOI2015 程序自动分析<br>JSOI2008 星球大战<br>NOI2001 食物链<br>NOI2002 银河英雄传说<br>UVA11987 Almost Union-Find</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>最小生成树（马上要去写）和LCA最近公共祖先（写完了，可以看）</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>很大一部分借鉴了OI WIKI<br>侵权勿喷。。。（我非盈利aaa<br>good bye</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
</search>
