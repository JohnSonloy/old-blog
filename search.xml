<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LCA</title>
    <url>/LCA/</url>
    <content><![CDATA[<h1 id="最近公共祖先-LCA-洛谷-P3379"><a href="#最近公共祖先-LCA-洛谷-P3379" class="headerlink" title="最近公共祖先 LCA 洛谷 P3379"></a>最近公共祖先 LCA 洛谷 P3379</h1><h2 id="今天-xiao-习了一下-LCA-过程十分曲折。。。"><a href="#今天-xiao-习了一下-LCA-过程十分曲折。。。" class="headerlink" title="今天 xiao 习了一下 LCA 过程十分曲折。。。"></a>今天 xiao 习了一下 LCA 过程十分曲折。。。</h2><p>（检查的时候主函数没有调用 dfs，调试了好几遍才发现。。。<br>首先，我们先来看一看定义：最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。<br>它有三种做法：</p>
<ol>
<li>暴力</li>
<li>倍增</li>
<li>树链剖分<br>遗憾的是我就会前两种；</li>
</ol>
<h2 id="第一种枚举"><a href="#第一种枚举" class="headerlink" title="第一种枚举"></a>第一种枚举</h2><p>我们有了这么一棵树，和其中的两个节点；那么我们只需要一个一个求出它们的祖先，一步步向上跳就可以找到交点，找到第一个交点就是最近公共祖先<br>显而易见，这是最为朴素的正解；<br>但不是最优解；<br>仔细一想就知道他可顶复杂度超高（给两个叶子结点最后回到根上）<br>明显过不去<br>那么就要想方设法优化</p>
<h2 id="第二种方法-倍增"><a href="#第二种方法-倍增" class="headerlink" title="第二种方法 倍增"></a>第二种方法 倍增</h2><p>倍增求 LCA 是最经典的方法了（不要问我谁提出来的问就是不知道）<br>上面朴素做法是一步一步向上跳，那么我们就可以很多步很多步向上跳，就可以优化；<br>而倍增就是优化的方法之一，以 logn 的时间复杂度来向上查询<br>只需要预处理出一个数组 f[u][i]u 是节点，i 是指 u 向上 2^i 个节点处（第 2^i 个祖先<br>那么我们就可以一步一步向上跳</p>
<h2 id="第三种方法-树链剖分"><a href="#第三种方法-树链剖分" class="headerlink" title="第三种方法 树链剖分"></a>第三种方法 树链剖分</h2><p>我不会。。。……以后再写</p>
<h2 id="上代码："><a href="#上代码：" class="headerlink" title="上代码："></a>上代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> next,v;</span><br><span class="line">&#125;cun[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],d[maxn],f[maxn][<span class="number">22</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cun[++tot].next=head[x];head[x]=tot;cun[tot].v=y;<span class="comment">//结构体存链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=d[fa]+<span class="number">1</span>;<span class="comment">//子节点深度是父节点加一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[u][i+<span class="number">1</span>]=f[f[u][i]][i];<span class="comment">//可以自己推导（就是乘个二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=cun[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=cun[i].v;<span class="comment">//邻接表向后查询</span></span><br><span class="line">        <span class="keyword">if</span>(a==fa)<span class="keyword">continue</span>;<span class="comment">//不查询父节点</span></span><br><span class="line">        f[a][<span class="number">0</span>]=u;<span class="comment">//a是u的子节点，向上跳2^0是父节点u</span></span><br><span class="line">        <span class="built_in">dfs</span>(a,u);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);<span class="comment">//后面方便</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从后向前找，二进制拆分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];<span class="comment">//如果深度大就向上跳到相等为止</span></span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;<span class="comment">//如果同一深度时相等就相当于y是x的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])<span class="comment">//向上跳不相等的话就向上跳</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];y=f[y][i];<span class="comment">//继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*由于向上跳容易误判，所以我们选择向上跳到同一父节点时停止，最后输出父节点</span></span><br><span class="line"><span class="comment">        向上跳无论如何都相等时就是同一父节点了*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];<span class="comment">//父节点便是LCA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        <span class="built_in">add</span>(x1,y1);</span><br><span class="line">        <span class="built_in">add</span>(y1,x1);<span class="comment">//无向图需要双向添加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">LCA</span>(x1,y1)&lt;&lt;endl;<span class="comment">//直接输出返回的就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尾声-Johnsonloy-的-LCA-过啦（以后会补全树链剖分的内容滴-Q-Q"><a href="#尾声-Johnsonloy-的-LCA-过啦（以后会补全树链剖分的内容滴-Q-Q" class="headerlink" title="尾声 Johnsonloy 的 LCA 过啦（以后会补全树链剖分的内容滴 Q-Q"></a>尾声 Johnsonloy 的 LCA 过啦（以后会补全树链剖分的内容滴 Q-Q</h2>]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>MST</title>
    <url>/MST/</url>
    <content><![CDATA[<h1 id="MST-最小生成树板子"><a href="#MST-最小生成树板子" class="headerlink" title="MST 最小生成树板子"></a>MST 最小生成树板子</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天对我的图论知识进行了一次的扩充，最小生成树<br>前言知识：并查集，可以去翻我的博客虽然还不完善但也有一点点的用途</p>
<h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>kruskal 算法由 kruskal 发明（废话），本质思想是在两个最小联通块之间找到最小的边使得这两联通快之间合并代价最小（就是边权<br>所以，kruskal 算法是一个贪心的做法<br>我们按照最小的边权一个一个加入，只要加入不产生环，就把这个点和这个边放进一个点集里<br>所以，不产生环。。。怎么做呢。。。<br>并查集咯。<br>很简单，再加入一条边的时候，就相当联通两个联通块，如果这两个联通块本来就是联合的，加入就会构成一个环<br>所以只要并查集查找这条边的两个点是不是已经被联通的了就好了<br>证明就是一个环中删掉最大的边的意思（差不多。。。可以去看 OIWIKI<br><a href="https://oi-wiki.org/graph/mst/">https://oi-wiki.org/graph/mst/</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>P3366</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;bian[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mm p,mm q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.z&lt;q.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[p]==p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">find</span>(p);q=<span class="built_in">find</span>(q);</span><br><span class="line">    fa[p]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;bian[i].x&gt;&gt;bian[i].y&gt;&gt;bian[i].z;</span><br><span class="line">    <span class="built_in">sort</span>(bian+<span class="number">1</span>,bian+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(bian[i].x)!=<span class="built_in">find</span>(bian[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=bian[i].z;</span><br><span class="line">            <span class="built_in">merge</span>(bian[i].x,bian[i].y);</span><br><span class="line">            <span class="keyword">if</span>(++num==n<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prim-算法："><a href="#prim-算法：" class="headerlink" title="prim 算法："></a>prim 算法：</h2><p>由于本人不是很会写 prim，经常写的是 kruskal。。。所以就不给放程序这种东西了。。。不过一些思路我还是会的<br>prim 算法和 kruskal 异曲同工，不过，prim 算法不是加边，而是加点<br>prim 算法也是维护一个连通块<br>每次加进去一个距离自己最近的点，加入自己，在更新所有点的距离（重新更新<br>就像是 dijkstra。。。每次找一个最近的去更新其他的节点距离<br>所以。。。它也能堆优化<br>不过就算是堆优化也没有 kruskal 跑的快<br>所以 建议使用 kruskal</p>
<h2 id="最小生成树的延伸————次小生成树"><a href="#最小生成树的延伸————次小生成树" class="headerlink" title="最小生成树的延伸————次小生成树"></a>最小生成树的延伸————次小生成树</h2><p>次小生成树分为两种：不过差不多就是能不能等于 1.非严格次小生成树<br>边权和大于等于最小生成树</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>1613</title>
    <url>/P1613/</url>
    <content><![CDATA[<p>P1613 跑路 一道小绿题<br>虽然这只是一道小绿题但是我觉得还是有必要总结一下的因为不错</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有辆很 n i u b i 的汽车一秒钟可以跑 2 的任意整次方的距离<br>给你一个有向图问：从 1 跑到 n 最短时间（边权都是 1）</p>
<h1 id="先给一会思考一下"><a href="#先给一会思考一下" class="headerlink" title="先给一会思考一下"></a>先给一会思考一下</h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，题目描述就让我们很容易想到倍增这个算法<br>我们需要把所有的边都存起来<br>但是一个问题是，在有向图上倍增……会炸……<br>很容易想到如果我们进行倍增，图并不支持随机访问（不是树）显然要一个一个跳，一定会炸<br>所以：一个 dp 的思路就出来了（严格意义上的 dp，但不严格意义上我一般不把他算作 dp）<br>就是<strong>floyd</strong><br>我们考虑倍增的思想：如果我从 p 点走 2^n-1 到另一个点，再从另一个点走 2^n-1 可以走到 q 点，那就说明我们可以 p-&gt;q 走 2^n 距离（就是 1 秒）<br>那么，我们再运用 floyd 的思路，如果 j 到 i，i 到 k 都是 1 秒，那么 j 到 k 就是 1 秒<br>我们只需要再 floyd 的三重循环外面加一个循环对倍增的那一维进行判断就可以了<br>floyd 之后：<br>我们已经求出了那个点到那个点是 1 的距离，但显然我们可能不会起点到终点一定是 1s<br>所以我们需要跑最短路<br>在 floyd 求得 dis 数组的基础上，跑一遍最短路，就是最后的最短时间</p>
<h1 id="代码时间"><a href="#代码时间" class="headerlink" title="代码时间"></a>代码时间</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 70</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        f[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dis[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= <span class="number">64</span>; u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (f[j][i][u - <span class="number">1</span>] &amp;&amp; f[i][k][u - <span class="number">1</span>])</span><br><span class="line">                        f[j][k][u] = <span class="number">1</span>,</span><br><span class="line">                        dis[j][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                dis[j][k] = <span class="built_in">min</span>(dis[j][k], dis[j][i] + dis[i][k]);</span><br><span class="line">    cout &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完结撒花<br>还蛮有意思的一道题……</p>
]]></content>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/Tree/</url>
    <content><![CDATA[<h1 id="Tree-洛谷-P2619"><a href="#Tree-洛谷-P2619" class="headerlink" title="Tree 洛谷 P2619"></a>Tree 洛谷 P2619</h1><p>一道生成树的很好的题目</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 need 条白色边的生成树。<br>乍一看还是很没有头绪的（反正刚开始我没有</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于我们需要求一个最小权的，恰好有 need 条边的生成树<br>首先可以想到一个贪心的作法就是我先把最小的白边加入生成树之中直到 need 条跑 MST<br>再把黑边跑 MST 加入生成树中<br>但显然。。。这个贪心的策略非常不对。。。<br>因为白边的长度和加上黑边的长度和才会是总长度和，如果黑边要加入 2 条边，共有三条边，为 1,2,99999……黑边是会影响到白边的选取的，所以我们需要从整体上考虑问题，考虑同时加入白边黑边的时候应该如何进行选取最优<br>那我们先跑一遍 MST，求出加入的白边的个数此时加入的百变个数与 need 一定是有差别的（如果等于了直接输出就可以了）<br>我们想要从整体上考虑问题，那么我们就改变 MST 的过程就好了<br>但是怎么改变就是一个问题……<br>kruskar 的过程是要进行排序的，那我们就……改变权值就可以了呀！<br>我们将白边的权值进行改变，在每次与 need 不相符的时候就进行一次改变权值，就可以进行对百变加入生成树的过程的改变<br>如果我们将白边的权值增大以至于最小的可以加入的次小黑边，就将那条黑边加入，把这条黑边弹出，这样我们是可以获得最小的取出一条白边的代价的（因为需要一点点增加）<br>所以正解思路就具备了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现过程中，我们将白边的权值一点点的改变……<br>聪明的同学就想到了：<br>复杂度可能有点不对（然后开始 diss 我）<br>不要着急。。。题目中给定的边权是小于等于 100 的，我们进行二分就可以了呀<br>二分答案是一个很好的东西（虽然在这道题中不二分似乎也可以过去，我没有试验过，但是数据范围改一改就可以看到二分答案的优势了）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（由于是过了好长时间才回来写的博客所以有点生疏了）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> v,e,need;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,val,c;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a1,node a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a1.val==a2.val)<span class="keyword">return</span> a1.c&lt;a2.c;<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">return</span> a1.val&lt;a2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,check;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;check=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v+<span class="number">1</span>;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+e,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;cnt!=v<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aa=<span class="built_in">find</span>(a[i].u),bb=<span class="built_in">find</span>(a[i].v);</span><br><span class="line">        <span class="keyword">if</span>(aa!=bb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].c==<span class="number">0</span>)check++;<span class="comment">//白边</span></span><br><span class="line">            <span class="built_in">merge</span>(aa,bb);</span><br><span class="line">            ans+=a[i].val;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kruskal判断这一次进行MST后生成树的白边数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;e&gt;&gt;need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].val&gt;&gt;a[i].c;</span><br><span class="line">        a[i].u++;a[i].v++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">-105</span>,r=<span class="number">105</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val+=mid;</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">        <span class="keyword">if</span>(check&gt;=need)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">            num=ans-need*mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val-=mid;</span><br><span class="line">        <span class="comment">//对要加的长度进行二分答案，最后的结果再减去白边所加上的权值和</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>P1827</title>
    <url>/shu/</url>
    <content><![CDATA[<h1 id="P1827-奶牛"><a href="#P1827-奶牛" class="headerlink" title="P1827 奶牛"></a>P1827 <strong>奶牛</strong></h1><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a><strong>题目解读</strong></h2><p>其实说到底就是一道树的后序遍历反推而已嘛<br>首先，让我们看一遍题目：<br>给了一棵树的前序中序遍历，让求出后序遍历；（习惯性的打出分号<br><a href="https://oi-wiki.org/graph/tree-basic/#_14%EF%BC%88%E9%99%84%E4%B8%8AOI-WIKI%E7%9A%84%E8%AE%B2%E8%A7%A3">https://oi-wiki.org/graph/tree-basic/#_14（附上OI-WIKI的讲解</a><br>首先我们知道前序遍历在开头是根节点，那么，就将根节点取出（用 string 可做到<br>那么，在中序遍历中找到根节点的位置，左边就是左子树，右边就是右子树<br>在左子树中，前序遍历的<strong>左半截</strong>的开头就是左子树的根节点，再将根节点取出，再在中序遍历的<strong>左半边</strong>寻找……<br>然后再在右子树中重新做一遍这个过程，<em>（注意）</em>重新做的时候也要从左子树开始做<br>！！！这是什么！！！<br>赤裸裸的递归啊<br>所以！就可以用一个递归小函数来解决这个问题</p>
<h2 id="另一件事情"><a href="#另一件事情" class="headerlink" title="** 另一件事情 **"></a>** 另一件事情 **</h2><p>在上述说明中呢，看上去非常的简单；<br>但是，上面提到了前序遍历的左半边，难道是说要在存一个 string 做吗；<br>是的，需要————<br>但是不要惊慌<br>接下来我要说的就是 string 的库函数之一：substr()；<br>substr(本质上是复制字符串的一部分放入新的字符串之中；<br>就省得孩子们一遍遍的 for 了</p>
<h2 id="上代码："><a href="#上代码：" class="headerlink" title="** 上代码：**"></a>** 上代码：**</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string aa,string bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa.<span class="built_in">empty</span>())<span class="keyword">return</span>;       <span class="comment">//这是在判断边界</span></span><br><span class="line">    <span class="keyword">char</span> root=aa[<span class="number">0</span>];        <span class="comment">//将前序遍历的根节点取出来</span></span><br><span class="line">    <span class="keyword">int</span> k=bb.<span class="built_in">find</span>(root);        <span class="comment">//找到根节点</span></span><br><span class="line">    aa.<span class="built_in">erase</span>(aa.<span class="built_in">begin</span>());       <span class="comment">//将根节点从string中删除</span></span><br><span class="line">    string laa=aa.<span class="built_in">substr</span>(<span class="number">0</span>,k),raa=aa.<span class="built_in">substr</span>(k),lbb=bb.<span class="built_in">substr</span>(<span class="number">0</span>,k),rbb=bb.<span class="built_in">substr</span>(k+<span class="number">1</span>);       <span class="comment">//激动人心的拆卸时间</span></span><br><span class="line">    <span class="built_in">dfs</span>(laa,lbb);<span class="built_in">dfs</span>(raa,rbb);      <span class="comment">//遍历</span></span><br><span class="line">    cout&lt;&lt;root；         <span class="comment">//由于是后序遍历所以最后输出根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">dfs</span>(b,a);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a><strong>尾声</strong></h2><p>森森的第一篇学术博客结束</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>tarjan</title>
    <url>/tarjan/</url>
    <content><![CDATA[<h1 id="花了-3-4-天的时间干掉了这个算法：tarjan（虽然只是干掉了板子）"><a href="#花了-3-4-天的时间干掉了这个算法：tarjan（虽然只是干掉了板子）" class="headerlink" title="花了 3-4 天的时间干掉了这个算法：tarjan（虽然只是干掉了板子）"></a>花了 3-4 天的时间干掉了这个算法：tarjan（虽然只是干掉了板子）</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>我刚开始学了一天的无向图，看懂了板子之后，机房大佬告诉我先学有向图的比较好……然后就开始学有向图……<br>有向图 tarjan 的内容比较少，只有强连通分量，缩点，必经点和必经边</p>
<h3 id="前置定义"><a href="#前置定义" class="headerlink" title="前置定义"></a>前置定义</h3><p>给定一个有向图，如果在这个有向图中存在一个点，从它出发可以到达图中所有的点，那么称这个图为：<strong>流图</strong><br>我们在这个流图上进行 dfs，每个点访问一次，所有的访问的点和边构成一棵树，我们称之为<strong>搜索树</strong><br>同时，在 dfs 的过程中，我们搜到每一个点的顺序（1-N），我们把这个点按照这个顺序进行标记，这个标记我们规定它为<strong>时间戳</strong>，记为 dfn[x]<br>流图中的每一条有向边(x,y)都必然是以下四种之一： 1.树枝边：搜索树中的边，即：x 是 y 的父节点 2.前向边：x 是 y 的祖先节点但不是父节点 3.后向边：y 是 x 的祖先节点 4.横叉边：（就是除了这三种情况的边）这条边一定满足：$dfn[y] &lt; dfn[x]$;（因为如果 dfn[x] &lt; dfn[y]的话，y 就会成为 x 的子节点）</p>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>强联通：存在路径 x-&gt;y 也存在路径 y-&gt;x 那么 x,y 强联通<br>给定一张有向图。如果对于图中任意两个节点 x,y 都满足两点强联通，那么这张有向图就是一张强连通图<br>有向图的极大强连通子图被称为强连通分量，简写为 SCC<br>那么介绍<strong>tarjan 算法</strong>：<br>一个环一定是一张强联通图。tarjan 的基本思路就是对于每一个点 x,都去寻找那些与 x 可以构成环的所有节点将他们放进一个强连通分量中去<br>容易发现：前向边没用，直接扔掉就好<br>后向边极其有用，因为有一条后向边就可以形成一个环<br>横叉边不一定，横叉边过去到另一棵子树上的节点可能是可以回去构成一个环的，也有可能并不能构成环</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>那么我们为了让这两种边有用途，我们需要维护一个栈保存以下两类节点：</p>
<p>1.搜索树中的祖先节点<br>如果存在一条后向边，那么构成一个环</p>
<p>2.已经访问过，并且存在一条路径到达祖先节点的点（横叉边）<br>如果 z 是一个这样的点，从 z 出发存在一条路径到达祖先节点，那么如果存在一条横叉边，就可以构成一个环</p>
<p>（以下几行建议等会再食用）</p>
<p>在实现过程中，对于横叉边，我们进行遍历时，栈中剩下的节点一定是此次访问的节点，并且暂时不属于任何一个强连通分量，那么这个节点一定可以和我们当前的点形成强联通分量（因为这个节点一定可以抵达横叉边对应的边的两个端点的 lca），所以他们一定可以构成一个强连通分量……所以这就是横叉边的用途</p>
<p>进而：我们引入一个概念：追溯值</p>
<h4 id="追溯值"><a href="#追溯值" class="headerlink" title="追溯值"></a>追溯值</h4><p>x 的追溯值 low[x]定义为满足以下节点的最小的时间戳：</p>
<p>1.该点在栈中</p>
<p>2.存在一条从 subtree(x)出发的有向边，以该点为终点<br>根据定义 tarjan 算法按照以下步骤计算追溯值</p>
<p>1.当节点 x 第一次别访问到的时候，把 x 入栈，初始化 $low[x]=dfn[x]$；</p>
<p>2.扫描从 x 出发的每一条边（x，y）</p>
<p>(1)若 y 没有被访问过说明（x，y）是树枝边，递归 y：$low[x]=min(low[x],low[y])$;</p>
<p>(2)若 y 被访问过并且 y 在栈中，则令 $low[x]=min(low[x],dfn[y])$，但是请注意：在有向图的追溯值中,dfn[y]也可以改为 low[y]（因为只要不一样就算进强连通分量里，详细看第三点），但由于我们的无向图 tarjan 是不能的，所以建议使用 dfn[y]，不容易出锅。另外一条：y 被访问过，并且 y 在栈里，那么说明……这是一条树枝边！（如果不理解，就先记住，看完了下面你会知道为什么我会说这些的）</p>
<p><strong>3.从 x 回溯之前，判断是否有 low[x]=dfn[x]。若成立，则不断从栈中弹出节点，直至 x 出栈（这点很重要）</strong><br>童鞋们可以手摸一下，下面给一组数据：<br>1-&gt;2 2-&gt;3 3-&gt;4 4-&gt;5 5-&gt;2 1-&gt;6 6-&gt;7 7-&gt;4 6-&gt;8 8-&gt;7 8-&gt;9 9-&gt;6（编号都直接为 dfn 了，1 为根节点）<br>1:1 2:2 3:2 4:2 5:2 6:6 7:7 8:6 9:6 （追溯值）</p>
<h4 id="强连通分量的判定法则："><a href="#强连通分量的判定法则：" class="headerlink" title="强连通分量的判定法则："></a>强连通分量的判定法则：</h4><p>在追溯值的计算过程中，x 回溯之前 $low[x]=dfn[x]$成立，就从栈中从 x 到栈顶所有节点构成一个强连通分量<br>大致来说，在计算追溯值的第 3 步，如果 $low[x]=dfn[x]$，那么说明 subtree[x]中的所有节点不能与栈里的任何一个其他节点构成环（因为上不去）另外：横叉边的终点时间戳一定比起点时间戳小（上面有说）所以 subtree[x]中的节点不可能到达任何一个没有被访问的节点（子树）（或根节点另一个子树）<br>又因为我们及时进行了判定和出栈的操作，所以从 x 到栈顶的所有节点构成一个强连通分量，而如果这个强连通分量中的点是某一条没有被搜索到的横叉边的终点，这条横叉边的起点一定不能与这个强连通分量中的点构成强连通分量（就废了），而强连通分量中的点会被 pop 出去，所以 vis 数组会变成 0，所以可以去食用上面的三行了。<br>程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    sta[++top] = x, vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nex)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[e[i].v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e[i].v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[e[i].v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[e[i].v])</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[e[i].v]);</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = sta[top--], vis[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt;</span><br><span class="line">            w[cnt] += a[y];</span><br><span class="line">            sc[cnt]++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们的强连通分量是每一个点都可以互相到达的，那么我们科室适当的考虑一下能不能把这几个点看成一个点来进行问题的处理，这样我们就可以引入一个概念叫做：<strong>缩点</strong></p>
<p>我们可以吧每一个 SCC 缩成一个点，对于原图中的每一条有向边，如果 $c[x]!=c[y]$，则在编号为 c[x]和 c[y]的 SCC 之间连上一条边，最后我们会得到一张 DAG(有向无环图)<br>下面的程序对 SCC 进行缩点操作：以洛谷缩点板子题为例 P3387</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_c</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ed[++totd] = &#123;y, hd[x]&#125;;</span><br><span class="line">    hd[x] = totd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = e[j].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[e[j].v])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        in[c[e[j].v]] += <span class="number">1</span>;<span class="comment">//这个是统计入度，因为需要用到拓扑排序</span></span><br><span class="line">        <span class="built_in">add_c</span>(c[i], c[e[j].v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有向图的必经点和必经边"><a href="#有向图的必经点和必经边" class="headerlink" title="有向图的必经点和必经边"></a>有向图的必经点和必经边</h3><p>给一张有向图，起点为 S 终点为 T，若从 S 到 T 的每一条路径都经过一个点或者一条边，那它就被称为 S 到 T 的必经点或必经边<br>Lenguar-tarjan 算法通过计算支配树求出必经点集，但是…………板子题是黑题，我还是不想了<br>但是还是有方法计算有向无环图的必经点必经边的：</p>
<p>1.在原图的拓扑序上进行 DP，求出 S 到点 x 的路径条数 fs[x]</p>
<p>2.在返图上再次 DP 计算从点 x 到终点 T 的路径条数 ft[x]<br>显然根据乘法原理： 1.对于一条有向边来说（x，y）若 $fs[x]*fs[y]=fs[T]$，则(x,y)是必经边 2.对于一个点 x，若 $fs[x]*ft[x]=fs[T]$则 x 是必经点</p>
<h3 id="有向图写完了，就该进行无向图的博客之旅了！（前方道路淤堵。。。请保持好车距。。。）"><a href="#有向图写完了，就该进行无向图的博客之旅了！（前方道路淤堵。。。请保持好车距。。。）" class="headerlink" title="有向图写完了，就该进行无向图的博客之旅了！（前方道路淤堵。。。请保持好车距。。。）"></a>有向图写完了，就该进行无向图的博客之旅了！（前方道路淤堵。。。请保持好车距。。。）</h3><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图的知识前端部分比较简单，因为我们有了有向图的基础<br>但是后面就会有一点难咯</p>
<h3 id="无向图的割点与桥"><a href="#无向图的割点与桥" class="headerlink" title="无向图的割点与桥"></a>无向图的割点与桥</h3><p>0<br>给定一张无向连通图<br>若删去其中一个节点和与它相连的所有边之后，这张图分裂成两个或两个以上的不相连的子图，则称 x 为 G 的割点<br>若删去其中一条边之后，这张图分裂成两个不相连的子图，则称 e 为 G 的桥或割边<br>Tarjan 大佬做过的贡献：斐波那契堆（毒瘤东西）、Splay Tree（毒瘤东西）、Lint-Cut Tree（已经被踢出考纲的东西）等。。。</p>
<p><strong>时间戳</strong><br>在图的 dfs 过程中，按照没一个节点第一次被访问的时间顺序进行标记（参照有向图时间戳）</p>
<p><strong>搜索树</strong><br>参照有向图搜索树（上面有）</p>
<h4 id="追溯值-1"><a href="#追溯值-1" class="headerlink" title="追溯值"></a>追溯值</h4><p>重要的东西，和有向图有一点点不一样<br>low[x]定义为以下节点的时间戳的最小值：<br>1.subtree(x)中的节点 2.通过 1 条不在搜索树上的边能够到达 subtree(x)的节点<br>初始化：low[x]=dfn[x]<br>如果在搜索树上 x 是 y 的父节点，$low[x]=min(low[x],low[y])$<br>如果(x,y)不是搜索树上的边则 $low[x]=min(low[x],dfn[y])$<br>除了根节点之外，一条边如果不是搜索树上的边，那么这一条边一定能与其他节点构成一个环（树嘛，这个轻轻想想就知道了）</p>
<h4 id="割边判定法则："><a href="#割边判定法则：" class="headerlink" title="割边判定法则："></a>割边判定法则：</h4><p>无向边(x,y)是桥，当且仅当搜索数上存在 x 的一个子节点 y，满足：</p>
<p>$$dfn[x] &lt; low[y]$$</p>
<p>根据定义 dfn[x] &lt; low[y]说明从 subtree(y)出发，在不经过(x,y)的情况下，是无法达到搜索树上 x 或者是比 x 更早访问的节点的 <strong>（如果一条不是搜索树上的边(x,y)（x &lt; y），那么 y 一定在 x 的子树里，所以我访问一定只会访问到比自己 dfn 小的点（大的也会访问但是没用）</strong> 所以若是删去这条边，subtree(y)就好像形成了一个封闭的环境，与节点 x 没有边相连接<br>读者不难发现：桥一定是搜索树上的边，并且一个简单环中的边一定不是桥<br>下面的程序求出一张无向图中所有的桥。特别注意：(x,y)是不能用来更新 low 数组的，所以我们可以进行父节点的标记<br>但是如果这样是处理不了重边的，那么我们考虑，改为记录进入没一个节点的边的编号：<br>边我们用链式前向星进行存储的时候我们会发现一条是会被记录两次的，所以如果将编号为 i 的边进行了标记，我们还需要将编号为 i^1 的边进行标记</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> in_edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[e[i].y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e[i].y, i);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[e[i].y]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &lt; low[e[i].y])</span><br><span class="line">                bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>))</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[e[i].y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (bridge[i])</span><br><span class="line">            cout &lt;&lt; e[i ^ <span class="number">1</span>].y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e[i].y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="割点判定法则"><a href="#割点判定法则" class="headerlink" title="割点判定法则"></a>割点判定法则</h4><p>如果 x 不是搜索树的根节点的话，那么 x 是割点当且仅当搜索树中存在 x 的一个子节点 y，满足：<br>dfn[x]&lt;=low[y]<br>特别的，如果 x 是根节点，那么 x 是割点当且仅当搜索树上存在至少两个子节点 y1,y2 满足条件<br><strong>证明：</strong><br><strong>不给，自己证去（模仿割边）</strong>lueluelue<br>下面给程序体会一下<br>洛谷板子题 P3388</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &lt;= low[v])</span><br><span class="line">            &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">1</span> || x != root)</span><br><span class="line">                    cut[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            root = i, <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (cut[i])</span><br><span class="line">            ans++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (cut[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h3><p>若一张无向连通图不存在割点，则称它为“点双连通图”，类比，不存在割边即为“边双连通图”<br>极大点双联通子图被称为点双连通分量简写为“v-DCC”，极大变双联通子图被称为边双连通分量<br>简称为“e-DCC”<br><strong>定理</strong>：<br>一张无向图是“点双连通分量”： 1.图的顶点不超过 2 2.图中的任意两点都通是包含在至少一个简单环中，简单环是指不自交的环<br>“边双连通分量”<br>当且仅当任意一条边都包含在至少一个简单环中</p>
<h4 id="e-DCC-的求法："><a href="#e-DCC-的求法：" class="headerlink" title="e-DCC 的求法："></a>e-DCC 的求法：</h4><p>求出无向图中所有的桥，删去</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加到原来的割边程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//进行dfs遍历一遍图，不经过桥边和已经被标记过的节点，如果经过桥边那么说明跨越了两个不一样的e-DCC</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x] = dcc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (c[y] || bridge[y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!c[i])</span><br><span class="line">            ++dcc, <span class="built_in">dfs</span>(i);<span class="comment">//dfs遍历</span></span><br></pre></td></tr></table></figure>

<h4 id="e-DCC-的缩点"><a href="#e-DCC-的缩点" class="headerlink" title="e-DCC 的缩点"></a>e-DCC 的缩点</h4><p>把每一个 e-DCC 看作一个节点，把桥边看做链接编号为 c[x],c[y]的 e-DCC 对应的节点的无向边，会产生一棵树</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot_edge] = &#123;y, head_edge[x]&#125;;</span><br><span class="line">    head_edge[x] = tot_edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main里的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].y, y = e[i ^ <span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">if</span> (c[x] == c[y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y);<span class="comment">//对每一条边进行扫描（双向边就进行两次扫描）只要扫描到了就添加进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot_edge; i += <span class="number">2</span>)</span><br><span class="line">        cout &lt;&lt; edge[i ^ <span class="number">1</span>].y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; edge[i].y &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="v-DCC-的求法"><a href="#v-DCC-的求法" class="headerlink" title="v-DCC 的求法"></a>v-DCC 的求法</h4><p>“点双连通分量”是一个极其容易误解的概念，不能直接删除割点<br>如果某一个节点是孤立点，则它自己单独构成一个 v-DCC。除了孤立点之外，v-DCC 的大小至少为 2。<br>虽然桥并不属于任何一个 v-DCC，但是一个割点可能会属于多个 v-DCC。<br>为了求出“点双连通分量”,我们需要在 Tarjan 算法的过程中维护一个栈，并按照如下的方法维护栈中的元素</p>
<p>1.当一个节点第一次被访问的时候，把这个节点入栈</p>
<p>2.当割点判定法则$dfn[x]&lt;=low[y]$成立的时候，无论 x 是否为根，都需要</p>
<p>(1)从栈顶不断弹出节点直至 y 被弹出<br>(2)被弹出的所有点和 x 一起构成一个 v-DCC</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    sta[++top] = x;<span class="comment">//这是比割点板子多了的一步栈</span></span><br><span class="line">    <span class="keyword">if</span> (x == root &amp;&amp; !head[x])<span class="comment">//孤立点直接跳过</span></span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &lt;= low[v])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">1</span> || x != root)</span><br><span class="line">                    cut[x] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//接下来是进行加入v-DCC的过程</span></span><br><span class="line">                <span class="keyword">int</span> y;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    y = sta[--top];</span><br><span class="line">                    dcc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">                &#125; <span class="keyword">while</span> (y != v);</span><br><span class="line">                <span class="comment">//跳栈，在第一次搜到就进行跳栈（由于加入栈之后x不一定上面的点就是当前的v所以要从栈顶跳到y之后再加入x节点）（因为一个割点可能同时是很多个V-DCC之中的）</span></span><br><span class="line">                dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            root = i, <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)cout&lt;&lt;dcc[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="v-DCC-的缩点"><a href="#v-DCC-的缩点" class="headerlink" title="v-DCC 的缩点"></a>v-DCC 的缩点</h4><p>v-DCC 的缩点比 e-DCC 复杂一点，因为一个割点可能会同时属于多个 v-DCC，设途中 p 割割点和 t 割 v-DCC。我们建立一张包含 p+t 个节点的新图，把每一个 v-DCC 和每一个割点都作为新图中的节点，并在每一个割点与包含他的所有 v-DCC 之间连边，这会构成一棵树</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num_ed=cnt,new_id[maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])new_id[i]=++num_ed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=dcc[i][j];</span><br><span class="line">            <span class="keyword">if</span>(cut[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_c</span>(i,new_id[x]);</span><br><span class="line">                <span class="built_in">add_c</span>(new_id[x],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tot_edge;i+=<span class="number">2</span>)</span><br><span class="line">        cout&lt;&lt;edge[i^<span class="number">1</span>].v&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;edge[i].v&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h2 id="无向图也写完了"><a href="#无向图也写完了" class="headerlink" title="无向图也写完了"></a>无向图也写完了</h2><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="对前缀和与差分进行总结，来源：洛谷题单"><a href="#对前缀和与差分进行总结，来源：洛谷题单" class="headerlink" title="对前缀和与差分进行总结，来源：洛谷题单"></a>对前缀和与差分进行总结，来源：洛谷题单</h1><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>（由于之前教练和我说可以刷一刷洛谷的题单刷刷基础我就去了</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前缀和有几种，一维和二维的用的比较多。"><a href="#前缀和有几种，一维和二维的用的比较多。" class="headerlink" title="前缀和有几种，一维和二维的用的比较多。"></a>前缀和有几种，一维和二维的用的比较多。</h2><p>一维前缀和比较简单，直接将数组的前几个加起来成一个单独的数组就可以<br>二维前缀和有点不一样：我们的二维前缀和处理的过程中不能直接通过上一个得到（需要三步操作其实也相当于直接得到。。。<br>在进行循环的时候，我们可以设想一下：<br>1 2 3<br>1 2 3<br>1 2 3<br>的前缀和 f[2][3]等于什么<br>显然它可以从 f[2][2]和 f[1][3]转移过来<br>但是都不一样 f[2][2]+f[1][3]会把 f[1][2]算两次<br>所以……减一下就可以<br>方程：f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1];<br>就可以进行处理了</p>
<h3 id="二维前缀和的例题：洛谷-P2004-领地选择"><a href="#二维前缀和的例题：洛谷-P2004-领地选择" class="headerlink" title="二维前缀和的例题：洛谷 P2004 领地选择"></a>二维前缀和的例题：洛谷 P2004 领地选择</h3><p><a href="https://www.luogu.com.cn/problem/P2004">题目链接</a><br>一道模板题。。。<br>处理二维前缀和，四个角顶点 x1,x2,y1,y2(x1&lt;x2,y1&lt;x2)ans=max(ans,f[x2][y2]-f[x1][y2]-f[x2][y1]+f[x1][y1]);<br>怎么推导意会一下就可以很简单</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分是一种很妙的算法，有的时候他可以自己单独成题，有的时候也可以配合着前缀和<br>因为：前缀和与差分是一对逆操作，前缀和序列差分一下就是原序列，差分序列前缀和一下也是原序列</p>
<h3 id="例题-1-IncDec-Sequence-CH0304（简称：蓝书例题）"><a href="#例题-1-IncDec-Sequence-CH0304（简称：蓝书例题）" class="headerlink" title="例题 1 IncDec Sequence CH0304（简称：蓝书例题）"></a>例题 1 IncDec Sequence CH0304（简称：蓝书例题）</h3><p>给定一个长度为 n(1e5)的序列，每次可以选择一个区间+1 或者-1<br>求至少多少次可以让序列所有数相等，再求，最少次数之下，序列最后多少种可能的值<br>序列所有数都相等代表了：差分序列除了第一个之外都为 0<br>那么：我们让差分序列 b 的 bn+1=0，每一次进行区间加减的时候都代表着我们要对差分序列中的两个数一个+1 另一个-1；<br>我们的目的是让 b2~bn 变成 0.<br>由于加一减一都是可以的，那么我们就没有区间进行加减时是否需要考虑+1 在前还是-1 在前这个限制了<br>（之前考试的时候有一道题是只给减法的，就比这个难一点，但其实也就相当于是特判，不难）<br>我们可以进行分类讨论： 1.选 bi,bj，在一个正另一个负的时候多进行操作 2.选 b1,bj，1 选完之后考虑 3.选 bi,bn+1，同样是 1 选完之后考虑<br>4.b1,bn+1，没有意义，舍去（因为 b1,bn+1 并不会对序列造成影响<br>第 1 类操作我们可以直接进行判断，判断序列中正数负数的绝对值，这两个的差就是 1 的次数<br>而第二第三次直接判断剩下的就可以，因为 2，3 操作事实上等价<br>综上所述，这个题第一问的答案就是两个数绝对值最大的那个（正负数分别的和的 max）<br>而第二问：因为是要求最小次数，操作一的次数等无影响，反正都会消耗完<br>那就考虑第 2,3 次操作的次数<br>如果我们第 2,3 次操作次数为 m<br>我们就可以进行选择进行那次操作，每次选择操作会不一样，但既然是问值，那就询问差分序列的第一个值<br>考虑操作 2，每一次的操作 2 都会对 b1 进行更改，操作 2 至少 0 次，最多 m 次，共 m+1 中可能<br>m=max(p,q)-min(p,q)<br>完美解决。。。</p>
<h3 id="例题-2-洛谷-P2671-求和"><a href="#例题-2-洛谷-P2671-求和" class="headerlink" title="例题 2 洛谷 P2671 求和"></a>例题 2 洛谷 P2671 求和</h3><p>前缀和好题<br><a href="https://www.luogu.com.cn/problem/P2671">题目链接</a><br>我们先考虑题中给的三元组（x,y,z）<br>y-x=z-y 那么说明，x,z 同奇或者同偶<br>既然如此，我们考虑对 color 下手：<br>每一个 color 的奇数偶数分别存储，他们中的每一个都可以单独构成一个三元组<br>三元组的分数：<br>编号之和乘数字之和<br>如果一个一个找，复杂度会炸<br>那么我们就可以看看这个分数能不能下手：显然可以<br>(x+z)<em>(numx+numz)=x</em>numx+z<em>numx+numz</em>x+z<em>numz<br>在每一个三元组，我们的 x</em>numx 都会被算到，那就统计一下三元组的个数，运用结合律把这么多的三元组进行结合律<br>我们数列中的元素回合所有其他的元素构成一个三元组从而被算一次（不管比他小还是比他大）<br>元素还会和其他元素的 num 都乘一次<br>那么我们处理 cnt 数组（就是记录 color 奇数偶数的那个）乘奇偶数的前缀和减去当前的数加上 cnt 数组乘当前的数字<br>这道题就被巨佬的您切掉了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之前缀和与差分是可以用到很多的地方的<br>插粉还可以用在你自己想要的区间求和<br>比如你想让一段序列都加都减，直接在差分序列上改一改最后求一个前缀和就可以了<br>很 nice</p>
<h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天根据书上的指引，想要学习最小生成树，然而蒟蒻在 OI WIKI 上学习的时候被告知：<br>前置章节是并查集。。。<br>于是蒟蒻便用了一天的时间 A 了三道黄题一道蓝题（其实相当于一道黄题……<br>所以今天蒟蒻过来总结一番</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集是一种树形结构，通过名字我们可以知道：<br>并：合并，查：查询，集：集合<br>就是合并和查询一个集合<br>也可以相当于是联通块之间的判断。<br>我们把一个联通快之间的点放入一个点集之中，<br>并查集就可以查询这个点是不是在集合中（不知道集合的去预（复）习高一课本</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们看一个故事：<br>几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。<br>（来自于 OI WIKI）<br>我们的并查集就相当于是这个故事中的实现过程：<br>建立一棵树，将父亲自己的儿子放进儿子节点中<br>每次询问两个人是在哪一个家族（树）之中，就询问自己的父亲是否在家族（树）之中<br>如果两个人的某个祖先（c++意义上）相等，就相当于他们两个是在一个家族中的<br>但是，有一次，两个祖先对话，想将各自的家族合并到一起，这该怎么办。。。<br>好办！将一个祖先的爸爸改成另一个祖先就可以了，反正我们不在乎某一个节点的爸爸究竟是谁，显然我们只在乎两个人是否是同一个家族也就是需不需要去一(de)起(guo)祭(gu)拜(ke)。</p>
<h2 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h2><p>查找：<br>就像上述操作一样，建立一棵树，将某些儿子们放进并查集，访问就可以知道是那颗树<br>合并：<br>也像上面一样，改父亲<br>在最开始的时候，我们是不知道谁是谁的爸爸的，那么就让他们每一个人都是一个小家族，当我们知道了谁是谁的爸爸之后，进行一次合并操作，就可以让两个人变成同一个祖先<br>但是，如果每一次查找都要向上跳到最上面的祖先或者每一次合并都需要合并 n/2 个点，那么复杂度将会是巨大的。。。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩，顾名思义，就是将并查集查询的路径进行压缩<br>我们上面说到了，每一次查找都需要向上进行跳跃，一直跳到祖先一样（其实一般都需要直接爬到最上面<br>这样的复杂度真的很大<br>定义中说的是：我们要判断联通块，那么我们就把所有的儿子节点直接连向树根<br>之后再去判断就只需要 O（1）时间查询祖先了（虽然在预处理的时候不是 O1 但也快了不少</p>
<h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>说实话我不知道为什么要去这个名字，感觉很难受并且我找不到名字和操作之中的关系<br>上面有说到，我们在合并的时候，是要将一个祖先改成另一个祖先的儿子的<br>那么如果 n 个点，n-1 个点是一个集合，1 个点是一个集合，我们将它合并，要把 n-1 个点的爸爸都改一改，会很累<br>但如果我们把 1 个点的祖先更改，就会很简单的呢！（假装很厉害的样子<br>所以，每一次我们进行合并之前，都记录一下联通块的点数<br>每一次合并取一次 min，就会优化</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>其实启发式合并有没有无所谓，有的时候还可能增加你的时间复杂度（其实可能就是一个常数<br>在不用启发式合并只用路径压缩的复杂度其实也就是 mlogn 甚至说 ma(m,n)。。。<br>（所以我不会写启发式合并</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码就以洛谷的板子了 P3367</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="comment">//父节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;<span class="comment">//祖先的更改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="comment">//初始化，自己是一个小家族</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionset</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))cout&lt;&lt;<span class="string">&#x27;Y&#x27;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&#x27;N&#x27;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是非常的简单。。。<br>我反正是这么觉得的。。。<br>时间复杂度：<a href="https://oi-wiki.org/ds/dsu-complexity/">https://oi-wiki.org/ds/dsu-complexity/</a></p>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>其实带权并查集和普通的并查集没有什么太大的不同，只是在我们每一次改变权值的时候都改一下到根节点的距离罢了<br>（其实我也不会，明天学会再改博客）</p>
<h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><p>（不会，以后再说。。。）<br>（这种东西应该是要在以后重新发博客的。。。如果你以后在我的博客之中翻到了。。。就不要让我回来改博客了。。。很累的。。。）</p>
<h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>NOI2015 程序自动分析<br>JSOI2008 星球大战<br>NOI2001 食物链<br>NOI2002 银河英雄传说<br>UVA11987 Almost Union-Find</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>最小生成树（马上要去写）和 LCA 最近公共祖先（写完了，可以看）</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>很大一部分借鉴了 OI WIKI<br>侵权勿喷。。。（我非盈利 aaa<br>good bye</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="被迫营业，学习了树状数组"><a href="#被迫营业，学习了树状数组" class="headerlink" title="被迫营业，学习了树状数组"></a>被迫营业，学习了树状数组</h1><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="粗："><a href="#粗：" class="headerlink" title="粗："></a>粗：</h2><p>树状数组是一个基于二进制的数据结构，我们将每一个值存为区间右端点的一个“lowbit”长度的区间中，就构成了树状数组（真的是很粗。。。）</p>
<h2 id="细：简介"><a href="#细：简介" class="headerlink" title="细：简介"></a>细：简介</h2><p>首先，树状数组这个数据结构可以动态维护区间和，支持单点修改区间查询（其实还支持区间修改单点查询或者都一起支持，这个后续再讲，因为是扩展内容）<br>在学习快速幂算法的过程中，我们可以知道一个事实：<br>任意正整数都可以表示为 2 的整数次幂相加（也就是二进制分解）<br>那么，6=4+2（2^2+2^1），14=8+4+2（2^3+2^2+2^1）<br>那么我们可以将 1<del>6 这个区间表示为 1</del>4 并 5<del>6（具体为什么不是 1</del>2 并 3<del>6 一会再说）<br>1</del>14 可以表示为 1<del>8 并 9</del>12 并 13~14<br>我们就可以进行存储。<br>那么。。。如何存储或查询呢？<br>6 可以表示为（110）2,14 可以表示为（1110）2，我们可以通过一个小操作实现取出 110 最右边（最小的）那个 1，就是<strong>lowbit</strong>。</p>
<h2 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="lowbit 运算"></a>lowbit 运算</h2><p>lowbit 操作，涉及到了一些位运算的知识：<br>我们不妨设 n&gt;0，n 的第 k 位是 1,0<del>k-1 位是 0（1000000……）<br>那么我们先将 n 取反，此时第 k 位变成了 0，0</del>k-1 都是 1<br>我们再将 n 加上 1，那么最后的那 k 位就变回了原来的样子<br>但是：第 k+1 位往后，就变成了与之前相反的数<br>我们可以想到按位 and 操作：只要有一个不是 0，就把这一位变成 0，都是 1 变成 1<br>k+1 位往后是都相反的，那说明那几位中按位 and 运算一定会全部变成 0<br>第 k 位从始至终都是 1,0<del>k-1 位从始至终都是 0<br>那么这个数只剩下了 2^k-1<br>表示为：n&amp;(</del>n+1)<br>然而在补码的表示下，<del>n=-1-n，那么</del>n+1==-n<br>所以 lowbit 运算最后就变成了 n&amp;-n</p>
<h2 id="查询和存储"><a href="#查询和存储" class="headerlink" title="查询和存储"></a>查询和存储</h2><h3 id="存储-或者说是单点修改"><a href="#存储-或者说是单点修改" class="headerlink" title="存储(或者说是单点修改)"></a>存储(或者说是单点修改)</h3><p>在讲完了 lowbit 操作之后，就到了实现<br>查询的时候，我们还是以 n 来举例子<br>我们想要存储 1-n 的前缀和，就是分步走<br>7 存到 t[7]之后<br>我们就需要修改它的父节点<br>通过 lowbit 操作我们可以知道，我们现在存储的节点的区间长度是 lowbit(n)<br>我们想要到我们的父节点，父节点的区间长度应是我们的二倍(或者是和之前的进行拼接成为更大的区间)<br>所以我们应该让 lowbit 变大。<br>由我们的计算机存储方式二进制可以得到，lowbit 的这一位加上 1，会变成 0，然而更高的哪一位会加一（直到不能进位）（两个同样长的挨着的区间分别存储是不优的，因为我们是在存储前缀和，直接详见可以得到答案就不需要浪费空间进行存储），这正好顺应了我们想要存区间的需求，那我们就让 n 加上 lowbit（n）便是他的父节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x)</span><br><span class="line">        t[x] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>存储其实和查询有一点反操作的感觉<br>我们考虑一个区间 1<del>7<br>7=(111)2<br>那么，我们就可以知道，sum（1</del>7）=sum（1-4）+sum(5-6)+sum(7);<br>我们进行 7 的存储，就可以分步走：<br>首先将 sum（7）存储进 sum（1-7），7-=1 现在为 6<br>将 sum（5-6）存进 sum（1-7），6-=2 现在为 4<br>再将 sum（1-4）存进 sum（1-7，4-=4 现在为 0，结束<br>所以我们 sum(n)存的区间的长度就可以是 lowbit(n)<br>那样的话 sum(n-lowbit(n))存的就是下一位（100000……）直到变成 0<br>这就是树状数组的存储</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">        ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷 P3374，P3368 是模板题，可以去看看</p>
<h3 id="P1966-火柴排队-题目链接"><a href="#P1966-火柴排队-题目链接" class="headerlink" title="P1966 火柴排队 题目链接"></a>P1966 火柴排队 <a href="https://www.luogu.com.cn/problem/P1966">题目链接</a></h3><p>这道题倒是不难（我个人感觉应该到不了蓝色。。。）（我太菜了）<br>根据题目所说的是，两根火柴的距离定义为(a-b)^2，那么就让第 i 长的和第 i 长的放在一起，这样会是最小（贪心）<br>因为如果这样的话就相当于是火柴的对应关系固定的死死的，那么，我们就将火柴以编号命名（离散化但不完全离散化），然后求逆序对数<br>由于我们想让第 1 对应第 1，就相当于 a 数组 2 3 1 4，我将它变为 2-&gt;1,3-&gt;2,1-&gt;3,4-&gt;4，序列变为 1 2 3 4<br>然而 b 数组对应之后变成个 1 4 2 3，就相当于是冒泡排序求最少交换多少次，这个次数就是序列的逆序对数<br>（所以我说很简单嘛）<br>（代码）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 99999997</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c1[maxn], c2[maxn];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x)</span><br><span class="line">        t[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">        ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], c1[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; b[i], c2[i] = b[i];</span><br><span class="line">    <span class="built_in">sort</span>(c1 + <span class="number">1</span>, c1 + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">sort</span>(c2 + <span class="number">1</span>, c2 + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(c1 + <span class="number">1</span>, c1 + <span class="number">1</span> + n, a[i]) - c1;</span><br><span class="line">        b[i] = <span class="built_in">lower_bound</span>(c2 + <span class="number">1</span>, c2 + <span class="number">1</span> + n, b[i]) - c2;</span><br><span class="line">        q[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = q[a[i]];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">ask</span>(n) - <span class="built_in">ask</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P5677-配对统计-题目链接"><a href="#P5677-配对统计-题目链接" class="headerlink" title="P5677 配对统计 题目链接"></a>P5677 配对统计 <a href="https://www.luogu.com.cn/problem/P5677">题目链接</a></h3><p>这道题，其实也不难，但是我想了很长时间<br>（其实就是理解错题意了。。。）<br>我们考虑首先对于好的配对进行预处理，求出每一组好的配对<br>然后进行记录。记录的过程中，我们可以将配对放在一个数组中。<br>配对分几种情况：<br>首先，如果说我们将序列上的所有数字放在一条数轴上，一个数字对应的好的配对一定在它的两侧，那么分三种情况：<br>左边距离小，右边距离小，两边一样<br>就可以进行处理。两边一样的就有两组好的配对是当前数字的。<br>我们处理完配对之后，将它们在存储时改为左端点右端点单增（我只需要统计个数又不统计在哪）<br>我们对配对排序（以右端点升序排序），再将询问进行升序排序（同样是右端点）<br>我们枚举每一个询问，将右端点比询问的右端点小的配对的左端点放入树状数组（很绕口—）<br>我们统计左端点在 l<del>r 区间之内的个数，就是配对在 l</del>r 区间的个数（右端点比询问的右端点小，比自己的左端点大，所以只要我的左端点大于询问的左端点就可以是一个配对了）<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 600010</span></span><br><span class="line"><span class="keyword">int</span> n, m, t[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">no</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> q1, q2, pos;</span><br><span class="line">&#125; question[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qcmp</span><span class="params">(no x, no y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.q2 == y.q2)</span><br><span class="line">        <span class="keyword">return</span> x.q1 &lt; y.q1;</span><br><span class="line">    <span class="keyword">return</span> x.q2 &lt; y.q2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= n)</span><br><span class="line">        t[pos]++, pos += (pos &amp; -pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        sum += t[num], num -= (num &amp; -num);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num, pos;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.num &lt; y.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addq</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[++cnt].first = <span class="built_in">min</span>(x, y);</span><br><span class="line">    q[cnt].second = <span class="built_in">max</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.second == y.second)</span><br><span class="line">        <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i].num, a[i].pos = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="built_in">addq</span>(a[<span class="number">1</span>].pos, a[<span class="number">2</span>].pos);</span><br><span class="line">    <span class="built_in">addq</span>(a[n].pos, a[n - <span class="number">1</span>].pos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].num - a[i - <span class="number">1</span>].num &lt; a[i + <span class="number">1</span>].num - a[i].num)</span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i - <span class="number">1</span>].pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i].num - a[i - <span class="number">1</span>].num == a[i + <span class="number">1</span>].num - a[i].num)</span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i - <span class="number">1</span>].pos), <span class="built_in">addq</span>(a[i].pos, a[i + <span class="number">1</span>].pos);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i + <span class="number">1</span>].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + cnt, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; question[i].q1 &gt;&gt; question[i].q2, question[i].pos = i;</span><br><span class="line">    <span class="built_in">sort</span>(question + <span class="number">1</span>, question + <span class="number">1</span> + m, qcmp);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q[j].second &lt;= question[i].q2 &amp;&amp; j &lt;= cnt)</span><br><span class="line">             <span class="built_in">add</span>(q[j].first),j++;</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)(j - <span class="number">1</span> - <span class="built_in">ask</span>(question[i].q1 - <span class="number">1</span>)) * question[i].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树状数组结束-完结撒花"><a href="#树状数组结束-完结撒花" class="headerlink" title="树状数组结束 完结撒花"></a>树状数组结束 完结撒花</h1>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="一个可以累死人的数据结构"><a href="#一个可以累死人的数据结构" class="headerlink" title="一个可以累死人的数据结构"></a>一个可以累死人的数据结构</h1><h1 id="线段树（仅限于基础的那个）（zx-树这种的以后再说）"><a href="#线段树（仅限于基础的那个）（zx-树这种的以后再说）" class="headerlink" title="线段树（仅限于基础的那个）（zx 树这种的以后再说）"></a>线段树（仅限于基础的那个）（zx 树这种的以后再说）</h1><p>线段树是一个神奇的数据结构，他基本上什么区间操作都可以优化<br>这里讲一些基本的操作：单点修改，区间查询，区间修改（延迟标记）</p>
<h2 id="首先讲……概念…-我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点"><a href="#首先讲……概念…-我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点" class="headerlink" title="首先讲……概念…(我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点)"></a>首先讲……概念…(我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点)</h2><p>线段树，顾名思义，一个树形结构，存储的每一个节点都是一个线段<br>线段树的根节点存储着区间 1-n 的总信息，2 号存 1-（1+n）/2。。。<br>每一个线段的子节点都是自己线段的两半，直到叶子结点 l==r</p>
<h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p>我们在进行单点修改的过程中，一般指令都是这个样子：c x y，表示操作 a[x]=y；<br>我们可以知道，线段树维护的是一条线段，只有叶子结点维护的是点，那么，我们首先应该递归到叶子结点，然后修改值，再向上修改父节点，就以区间和为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r&amp;&amp;l==x)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p]=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(p*<span class="number">2</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    t[p]=t[p*<span class="number">2</span>]+t[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>我们查询一个区间的时候，绝对不可能只是查询一个节点，基本上每一次都会查询到多个节点，那么我们应该怎么实现呢<br>操作 1：首先一个区间 l-r，我们可能需要查询的区间为 x1-x2,x2-x3,x3-x4<br>首先，如果我们递归到了当前的节点，这个节点的线段是被我们查询的这个区间所覆盖住的，我们直接把这个节点统计到答案之中，应为我们可以分成若干个线段树的节点，所以只要我们一直递归，就一定可以地轨道两个节点，l-x5,x6-r，这之间的所有节点都是被我们操作 1 所统计的，所以直接把这个答案返回。<br>如果不懂可以自己手模一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l &amp;&amp; y&gt;=r) <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间修改（懒标记-laztag）"><a href="#区间修改（懒标记-laztag）" class="headerlink" title="区间修改（懒标记 laztag）"></a>区间修改（懒标记 laztag）</h2><p>这是一大难点啊。。。<br>首先对于我们上面的区间查询，我们可以感受到，线段树在对我们的区间进行一定的操作时，是可以划分为不同的节点进行操作的，那么，区间修改是否也可以这么做呢？<br>答案是肯定的<br>区间修改，在又一次经过操作 1 之后，我们就可以改变已经被覆盖的区间，比如区间和，我们就直接让这个区间增加 x*len(长度)，然后 return<br>可是这样并不满足我们的需要，因为区间修改的时候这样修改的确会直接将上面的数据进行修改，但是，我们如果多次操作，修改的次数一多，查询有交集的区间就会受影响，因此，我们引入懒标记：<br>懒标记是标记我们当前的节点需要进行区间修改，还是区间和为例，我们 laz[x]就代表着 x 节点的线段中每一个数都需要增加 laz[x]这么多，只要我们每一次在进行区间统计师，都将我们的父节点的 laztag 传下来，我们就知道，从最开始到现在，我们没、每一个节点总共需要至少增加多少(我说至少是因为当前节点的子节点(或者是子孙节点)可能 laztag 非零)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p*<span class="number">2</span>].pre+=t[p].add*(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>);</span><br><span class="line">        t[p*<span class="number">2</span>+<span class="number">1</span>].pre+=t[p].add*(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        t[p*<span class="number">2</span>].add+=t[p].add;</span><br><span class="line">        t[p*<span class="number">2</span>+<span class="number">1</span>].add+=t[p].add;</span><br><span class="line">        t[p].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=t[p].l &amp;&amp; y&gt;=t[p].r)&#123;</span><br><span class="line">        t[p].pre+=(<span class="keyword">long</span> <span class="keyword">long</span>)z*(t[p].r-t[p].l+<span class="number">1</span>);</span><br><span class="line">        t[p].add+=z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=t[p].l+t[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre=t[p*<span class="number">2</span>].pre+t[p*<span class="number">2</span>+<span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这玩意的例题可多可难。。。这几个题我都至少调了有 2hours</p>
<h3 id="P2471-降雨量-题目链接"><a href="#P2471-降雨量-题目链接" class="headerlink" title="P2471 降雨量 题目链接"></a>P2471 降雨量 <a href="https://www.luogu.com.cn/problem/P2471">题目链接</a></h3><p>这道题真的不错(难调)<br>首先这道题需要进行分类讨论：<br>对于我们查询的区间(l,r)<br>我们先判断 false： 1.左端点年份确定了，右端点年份不确定，那我们的中间的最大值大于左端点（我们的定义应该是左端点的降雨量比右端点大并且右端点比一整个区间之内别的都大，所以中间最大值大于左端点就不成立） 2.右端点年份确定，左端点不确定，那么中间的最大值大于右端点，同样不成立 3.都确定了，左端点小于右端点<br>然后是 maybe： 1.年份不连续：右端点减去左端点和左右端点年分之差不相等 2.左端点不确定 3.右端点不确定<br>（由于我们已经切掉了 false 的情况，所以只剩下了 maybe 和 true，而有任何一个不确定都不可能是 true，所以。。。直接扔掉）<br>只要不是 FALSE 或者是 maybe 那就是 true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400010</span></span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt] = b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (a[mid + <span class="number">1</span>] - a[mid] &gt; <span class="number">1</span> || c[rt * <span class="number">2</span>] || c[rt * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">        c[rt] = <span class="number">1</span>;</span><br><span class="line">    t[rt] = <span class="built_in">max</span>(t[rt * <span class="number">2</span>], t[rt * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(rt * <span class="number">2</span>, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx, yy;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        <span class="keyword">if</span> (xx &gt;= yy)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, xx) - a;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, yy) - a;</span><br><span class="line">        <span class="keyword">int</span> mm =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[x]!=xx)x--;</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;=y<span class="number">-1</span>)mm= <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((a[y]==yy&amp;&amp;mm&gt;=b[y])||(a[x]==xx&amp;&amp;mm&gt;=b[x])||(a[y]==yy&amp;&amp;a[x]==xx&amp;&amp;b[x]&lt;b[y]))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - x != a[y] - a[x] || a[x] != xx || a[y] != yy)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;maybe&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P5490-扫描线（也是-lyd-例题）题目链接"><a href="#P5490-扫描线（也是-lyd-例题）题目链接" class="headerlink" title="P5490 扫描线（也是 lyd 例题）题目链接"></a>P5490 扫描线（也是 lyd 例题）<a href="https://www.luogu.com.cn/problem/P5490">题目链接</a></h3><p>扫描线是一个非常经典的算法，可以用来求面积和，周长并等<br>以面积和为例：<br>我们放进坐标系中几个矩形，我们想要求出它们的面积和，第一可以想到用容斥原理，但他很慢。。。<br>我们考虑这么一件事情，我们假设有一条平行于纵轴的直线，他在随便移动。<br>对于我们矩形放在一起之后的形状，我们可以把这个图形分割成很多个小的没有交集的矩形<br>所以，我们可以把这条线进行左右移动，每次线和图形相交的地方是一定的，并且都是矩形，所以线的长度会有最多 2n 个，用这 2n 条线长度乘上横坐标的距离（矩形的宽度），就可以把我们的总面积求出来咯</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1&lt;&lt;21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sline</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,h,l,k;</span><br><span class="line">&#125;line[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">setree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,cnt,len;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt].l=l;t[rt].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(t[rt].l+t[rt].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> rk[maxn],val[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(sline mm,sline nn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mm.x&lt;nn.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].cnt)t[rt].len=val[t[rt].r+<span class="number">1</span>]-val[t[rt].l];</span><br><span class="line">    <span class="keyword">else</span> t[rt].len=t[ls].len+t[rs].len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[rt].l&amp;&amp;r&gt;=t[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt].cnt+=v;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(t[rt].l+t[rt].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(ls,l,r,v);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(rs,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx,x_x,yy,y_y,m=i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        cin&gt;&gt;xx&gt;&gt;yy&gt;&gt;x_x&gt;&gt;y_y;</span><br><span class="line">        line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].x = xx, line[i &lt;&lt; <span class="number">1</span>].x = x_x;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].h = line[i &lt;&lt; <span class="number">1</span>].h = y_y;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].l = line[i &lt;&lt; <span class="number">1</span>].l = yy;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].k = <span class="number">1</span>, line[i &lt;&lt; <span class="number">1</span>].k = <span class="number">-1</span>;</span><br><span class="line">        rk[++cnt]=yy;</span><br><span class="line">        rk[++cnt]=y_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rk+<span class="number">1</span>,rk+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">    cnt=<span class="built_in">unique</span>(rk+<span class="number">1</span>,rk+<span class="number">2</span>*n+<span class="number">1</span>)-rk<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1=<span class="built_in">lower_bound</span>(rk+<span class="number">1</span>,rk+<span class="number">1</span>+cnt,line[i].h)-rk;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="built_in">lower_bound</span>(rk+<span class="number">1</span>,rk+<span class="number">1</span>+cnt,line[i].l)-rk;</span><br><span class="line">        val[p1]=line[i].h;</span><br><span class="line">        val[p2]=line[i].l;</span><br><span class="line">        line[i].h=p1;</span><br><span class="line">        line[i].l=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(line+<span class="number">1</span>,line+<span class="number">1</span>+<span class="number">2</span>*n,cmp);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,line[i].l,line[i].h<span class="number">-1</span>,line[i].k);</span><br><span class="line">        ans+=t[<span class="number">1</span>].len*(line[i+<span class="number">1</span>].x-line[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有另一道题使用到了扫描线算法的（太累了不想写）<br>P1502 窗口的星星</p>
<h3 id="P4198-楼房重建题目链接"><a href="#P4198-楼房重建题目链接" class="headerlink" title="P4198 楼房重建题目链接"></a>P4198 楼房重建<a href="https://www.luogu.com.cn/problem/P4198">题目链接</a></h3><p>这道题是真的。。。很好。。。<br>首先很容易想到的是每一个数我们可以通过求斜率来判断是否能看见这栋楼<br>我们考虑答案，就是 1-n 这个区间之内，求单增的斜率个数最长递增的斜率<br>因为我们的区间是固定的，我们可以通过将区间分为两半进行处理，就可以想到使用线段树<br>线段树中维护两个信息：区间最大值和区间单增斜率数量<br>build,pushdown 都不需要。。。但是 pushup 操作就很烦。。。<br>最大值的 pushup 是很简单的，两个区间的最大值嘛<br>可是单增斜率数量是个很棘手的东西:<br>我们设 lx 为我 pushup 进这个大区间里，必须大于的最小值<br>先说边界：<br>如果 l==r 那 numk[rt]=a[l]&gt;lx;如果只有一个元素，那么我如果递归的原来区间的最左端是比它大于等于的，那 numk[rt]=0，否则等于 1（显然）<br>对于我需要 pushup 的区间，左半边区间可以直接 pushup 上去，没影响，右半边要考虑和左半边儿子的关系，lx 便是左区间的最大值<br>考虑右儿子的左右两个子区间：<br>设 s1 为左区间 s2 为右区间 1.如果 s1 的最大值小于等于 lx 直接舍去递归 s2 2.如果 s1 的最大值大于 lx 那么我的 s2 里原本看不看得见的直接 pushup 上去就可以，然而右半区间的看得见的应该是 numk[rk]-num[rk<em>2]而不是 numk[rk</em>2+1]因为右半区间有的是不能上去的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500010</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> nk[maxn];</span><br><span class="line"><span class="keyword">double</span> t[maxn], lv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushup</span><span class="params">(<span class="keyword">double</span> lx, <span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[rt] &lt;= lx)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lv[l] &gt; lx)</span><br><span class="line">        <span class="keyword">return</span> nk[rt];</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t[rt * <span class="number">2</span>] &lt;= lx)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pushup</span>(lx, rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pushup</span>(lx, rt * <span class="number">2</span>, l, mid) + nk[rt] - nk[rt * <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r &amp;&amp; r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt] = (<span class="keyword">double</span>)y/x;</span><br><span class="line">        nk[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(rt * <span class="number">2</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    t[rt] = <span class="built_in">max</span>(t[rt * <span class="number">2</span>], t[rt * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    nk[rt] = <span class="built_in">pushup</span>(t[rt * <span class="number">2</span>], rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r) + nk[rt * <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        lv[x[i]] = (<span class="keyword">double</span>)y[i] / x[i];</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, x[i], y[i]);</span><br><span class="line">        cout &lt;&lt; nk[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="撒花-完结-（终于-写完了）"><a href="#撒花-完结-（终于-写完了）" class="headerlink" title="撒花 完结 （终于**写完了）"></a>撒花 完结 （终于**写完了）</h1>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常中集训</title>
    <url>/%E5%B8%B8%E4%B8%AD%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="2-21"><a href="#2-21" class="headerlink" title="2.21"></a>2.21</h1><h2 id="Problem-A：count"><a href="#Problem-A：count" class="headerlink" title="Problem A：count"></a>Problem A：count</h2><blockquote>
<p>有一张n个点m条边的无向图。记$C_1$为这个图导出子图为 $K_4$的数量 ,$C_2$为补图导出子图为$K_4$的数量 （ $K_4$是4个点的完全图）</p>
<p>请你求出$C_1-C_2$的值.</p>
<p>n&lt;=5e4,m&lt;=1e5</p>
</blockquote>
<p><strong>前置知识：三元环计数，组合计数（一点点），容斥（思想），<del>脑子</del></strong></p>
<p>我们考虑这样一件事情：求出C2是很简单的，直接容斥：</p>
<p>我们设F0为四个点中至少有0条边的方案数，F1，F2……F6（最多6条边）</p>
<p>那C2不就是F0-F1+F2-F3+F4-F5+F6，然而我们仔细观察会发现……</p>
<p>F6不就是C1？那我们将式子进行移项就变成了：</p>
<p>C2-C1=F0-F1+F2-F3+F4-F5，（取个相反数不就行了）</p>
<p>然后我们转化完题意就可以进行计算了：</p>
<p><strong>细节看代码，有注释</strong><del>我就口胡一遍</del></p>
<ul>
<li><p>$F0$ 就等于N选4</p>
</li>
<li><p>$F1$ 就等于一条边，再从剩下的点中随便选出来两个（因为不一定有连边）</p>
</li>
<li><p>$F2$ 分两种情况：1.两条边有公共端点 2.没有公共端点，这样也好说，先枚举一条边，寻找与它没有公共端点的边，然后枚举公共点，计算出边</p>
</li>
<li><p>$F3$ 分几种情况：1.三元环2.一个点连着三条边3.一条链</p>
</li>
<li><p>$F4$ 也好说，1.三元环上连一条边挂上一个点2.四元环</p>
</li>
<li><p>$F5$ 需要脑子里想一下：只有一种情况就是两个有公共边的三元环</p>
</li>
</ul>
<h3 id="代码（含注释）"><a href="#代码（含注释）" class="headerlink" title="代码（含注释）"></a>代码（含注释）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn], g[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn];</span><br><span class="line"><span class="keyword">int</span> rk[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] == d[y])</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    <span class="keyword">return</span> d[x] &lt; d[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) * (n - <span class="number">3</span>) / <span class="number">24</span>; <span class="comment">// n选4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * m * (n - <span class="number">2</span>) * (n - <span class="number">3</span>) / <span class="number">2</span>; <span class="comment">//一条边两端随便选点（不重复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        res += m - (d[X[i]] + d[Y[i]] - <span class="number">1</span>); <span class="comment">//枚举边，寻找与它没有公共点的边</span></span><br><span class="line">    <span class="built_in">assert</span>(res % <span class="number">2</span> == <span class="number">0</span>);                   <span class="comment">//不知道有什么用——johnsonloy</span></span><br><span class="line">    res /= <span class="number">2</span>;                               <span class="comment">//去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        res += (n - <span class="number">3</span>) * <span class="number">1ll</span> * d[i] * (d[i] - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//有公共点</span></span><br><span class="line">                                                      <span class="comment">//枚举公共点为i，那么两条边连的点方案数就是d[i]*(d[i]-1)/2，由于我们要求的是K4的个数所以还需要乘（n-3）</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">        &#123;</span><br><span class="line">            c[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[j])</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[x = G[i][j]])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G[x].<span class="built_in">size</span>(); ++k)</span><br><span class="line">                    <span class="keyword">if</span> (rk[x] &gt; rk[y = G[x][k]] &amp;&amp; vis[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++res;</span><br><span class="line">                        ++cnt[g[x][k]];</span><br><span class="line">                        ++cnt[g[i][j]];</span><br><span class="line">                        ++c[y];</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[x = G[i][j]])</span><br><span class="line">                cnt[g[i][j]] += c[x], vis[x] = c[x] = <span class="number">0</span>; <span class="comment">//清空，覆盖次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求三元环的个数，还顺便求了一下每一条边被三元环覆盖的次数</span></span><br><span class="line">    res = res * (n - <span class="number">6</span>); <span class="comment">//第四个点，但是这里是乘的 n-6，是因为后面求链式结构的时候会多算三元环的情况，要减去，就直接加在这里了，这里是不管第四个点和另外三个点有没有边的，因为后面容斥会有减去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        res += <span class="number">1ll</span> * d[i] * (d[i] - <span class="number">1</span>) * (d[i] - <span class="number">2</span>) / <span class="number">6</span>; <span class="comment">//一个点连向另外三个点的情况（这种情况并不存在重复的情况……</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        res += <span class="number">1ll</span> * (d[X[i]] - <span class="number">1</span>) * (d[Y[i]] - <span class="number">1</span>); <span class="comment">//一条链的时候，就是一条边的两端点各自找另外一个点</span></span><br><span class="line">                                                    <span class="comment">//减掉三个三元环个数，因为每一个三元环的三条边在统计的时候都会再算一遍三元环，所以要减3</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[j])</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[j])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : G[j])</span><br><span class="line">                    <span class="keyword">if</span> (rk[j] &gt; rk[k] &amp;&amp; vis[k])</span><br><span class="line">                        res += d[i] + d[j] + d[k] - <span class="number">6</span>; <span class="comment">// 三元环上面挂着一个点的方案数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">            vis[j] = <span class="number">0</span>; <span class="comment">//清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	cerr &lt;&lt; &quot;res1 &quot; &lt;&lt; res &lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        c[i] = <span class="number">0</span>; <span class="comment">//还是清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[j])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : G[j])</span><br><span class="line">                    <span class="keyword">if</span> (rk[i] &gt; rk[k])</span><br><span class="line">                        res += c[k], ++c[k]; <span class="comment">//四元环计数，两边两条边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : G[i])</span><br><span class="line">            <span class="keyword">if</span> (rk[i] &gt; rk[j])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : G[j])</span><br><span class="line">                    c[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">f5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        res += cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//这一条边被多少个三元环覆盖了，那么我们就可以直接计算出来五条边是多少方案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; X[i] &gt;&gt; Y[i];</span><br><span class="line">        d[X[i]]++, d[Y[i]]++;</span><br><span class="line">        G[X[i]].<span class="built_in">push_back</span>(Y[i]);</span><br><span class="line">        G[Y[i]].<span class="built_in">push_back</span>(X[i]);</span><br><span class="line">        g[X[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        g[Y[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// G是出边，g是点所对的边的编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        id[i] = i; <span class="comment">//为了后面排序做准备</span></span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        rk[id[i]] = i; <span class="comment">//排序</span></span><br><span class="line">                       <span class="comment">//按照边的度数进行排序</span></span><br><span class="line">    LL v0 = <span class="built_in">f0</span>(), ans1 = <span class="built_in">f1</span>(), ans2 = <span class="built_in">f2</span>(), ans3 = <span class="built_in">f3</span>(), ans4 = <span class="built_in">f4</span>(), ans5 = <span class="built_in">f5</span>();</span><br><span class="line">    LL ans = v0 - ans1 + ans2 - ans3 + ans4 - ans5;</span><br><span class="line">    cout &lt;&lt; -ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 32 3 8 9 10 2 9 1 10 5 8 1 3 2 6 3 6 2 3 7 10 4 7 2 4 3 7 5 7 3 10 1 7 7 9 4 10 8 9 3 9 4 6 2 10 1 9 2 8 4 8 5 6 8 10 6 7 4 9 5 9 4 5 6 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Problem-B-geometry"><a href="#Problem-B-geometry" class="headerlink" title="Problem B geometry"></a>Problem B geometry</h2><p>平面几何……算了</p>
<h2 id="Problem-C-赌怪"><a href="#Problem-C-赌怪" class="headerlink" title="Problem C 赌怪"></a>Problem C 赌怪</h2><p>概率期望，算了</p>
<h1 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h1><h2 id="T1-排列"><a href="#T1-排列" class="headerlink" title="T1 排列"></a>T1 排列</h2><blockquote>
<p>对于一个1,2，…，n的排列a，我们会为它定义一个贡献：</p>
<p><img src="file:///C:\Users\DEll\AppData\Local\Temp\ksohtml\wpsE5F3.tmp.png" alt="img"></p>
<p>现在我们会随机生成一个排列，我们希望知道排列的贡献的期望是多少。 </p>
<p>$n&lt;=1e7,1&lt;=k&lt;=5,1e8&lt;p&lt;2^{31}$</p>
</blockquote>
<p><strong>容斥大好题啊！</strong></p>
<p>首先观察式子，会有贡献的$i$条件就是比两边都小；难点在于那个 k 次幂如何处理。</p>
<p>可以想象这样一件事，我们将有贡献的$i$单独拿出 ，然后相当于在这些拿出来的位置每次随便选一个，</p>
<p>如此 k 次，方案数就是那个式子。</p>
<p>考虑选到的位置组成一个集合，由于可以选择重复的位置，所以集合大小是小于等于 k 的。</p>
<p>将 ($i,a_i$)投影到平面上，而一个$i$合法就是 / 的形状。</p>
<p>可以发现形成了类似 …//…///…/… 的形状（称为锯齿形，点代表不选），而每一个最低点就是满足条件的$i$。</p>
<p>考虑计算出每一串连起来的锯齿形的方案数，然后 dp 拼凑起来计数。</p>
<p>怎么算 给 $2q+1$个数，将它们填入长度为 $2q+1$的序列并且投影满足锯齿形 的方案数呢？</p>
<p>很简单。可以发现 $q&lt;=k&lt;=5$，所以在另一个程序打一个暴力就可以算出来了：</p>
<p>前面是$2q+1$,后面的是$ans$。</p>
<p>$3:2<del>5:16</del>7:272<del>9:7936</del>11:353792$</p>
<p>有了这个之后题目就很简单了，我们使用 dp 计算出 $f[i][j][k]~,i,j,k$ 分别表示选择的位置的个数（可能选择重复的位置）（根据youwike所说i也可以说是块数）（代码注释有解释），所有锯齿的总长度，锯齿的数量。</p>
<p>（上面的是题解的内容）</p>
<p>代码注释是很全的（总比题解给的全多了）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, mod;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> inv[maxm], jie[maxm];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="keyword">int</span> g[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">272</span>, <span class="number">7936</span>, <span class="number">353792</span>&#125;;</span><br><span class="line"><span class="comment">// g函数代表的是，有i个波谷形状时的方案数</span></span><br><span class="line"><span class="comment">//暴力dp做法：设f[i][j]代表我放了后i个数（从大到小放），总共有j个波谷的方案数，由于我向波谷两旁放置最小的数时波谷数量并不会发生变化，所以不应该在波谷两旁放，然而波谷两旁总共有j*2个位置，所以我们可以从f[i-1][i-2*j]转移，产生贡献</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            sum = sum * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; x - y)</span><br><span class="line">        y = x - y;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x - y + <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">        res = res * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        res = res * inv[i] % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ku = <span class="number">1</span>; ku &lt;= <span class="number">5</span>; ku++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">//块的种类（块最多只有5种</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt;= <span class="number">15</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ge = i; ge &lt;= <span class="number">5</span>; ge++)</span><br><span class="line">                    f[ku][j][ge] = (f[ku][j][ge] + f[ku - <span class="number">1</span>][j - <span class="number">2</span> * i - <span class="number">1</span>][ge - i] * <span class="built_in">C</span>(j, <span class="number">2</span> * i + <span class="number">1</span>) % mod * g[i] % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp的过程：</span></span><br><span class="line"><span class="comment">首先我们设f[ku][j][ge]表示：我们选出ku个块（每一段连续的，首尾相接的V字形为一个块，块的总长度为j，块中总共有ge个V字形的总方案数</span></span><br><span class="line"><span class="comment">那我们的转移就变成了前一个块向当前块转移，然后我们枚举块的种类（一个波谷两个波谷……），2*i+1是块的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jie[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        inv[i] = <span class="built_in">qpow</span>(i, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++)</span><br><span class="line">        jie[i] = jie[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我们把题目转化为在所有的V字形中选出来k个V字形，可以选重复的的方案数，那么显然就是选一个的方案数的k次方</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; mod;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = <span class="built_in">qpow</span>(i, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i - j) &amp; <span class="number">1</span>)</span><br><span class="line">                num[i] = (num[i] - <span class="built_in">C</span>(i, j) * <span class="built_in">qpow</span>(j, k) % mod + mod) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num[i] = (num[i] + <span class="built_in">C</span>(i, j) * <span class="built_in">qpow</span>(j, k) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于我们在进行处理的时候，我们钦定了有i个V字形是必须要选的，那么我们就必须选上这几个V字形，这代表着我们需要进行容斥，如果说我们现在要钦定3个V，但是钦定了5次，那我们就需要容斥一遍，让每一个V都正好被钦定了1次</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">15</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= <span class="number">5</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= j)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = (ans + f[i][j][p] * num[p] % mod * <span class="built_in">C</span>(n, j) % mod * <span class="built_in">C</span>(n - j + i, i) % mod * jie[n - j] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f[i][j][p]代表意义上面dp过程是有的，乘容斥过程的数，C(n,j)代表的是在长度为n的原序列中选出来j的位置，C(n-j+i,i)代表我要将现在的序列插进原来的n-j的序列里的方案数，jie[n-j]是剩下的n-j个数的排列方案</span></span><br><span class="line">    <span class="comment">//由于我们在每一次算数的时候，都是以k次方为限制的，所以我们并不需要担心算重这一回事</span></span><br><span class="line">    cout &lt;&lt; (ans * <span class="built_in">qpow</span>(jie[n], mod - <span class="number">2</span>)) % mod &lt;&lt; endl;<span class="comment">//jie[n]是算期望</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T2-填数游戏"><a href="#T2-填数游戏" class="headerlink" title="T2 填数游戏"></a>T2 填数游戏</h2><p>……最小直径生成树，算了</p>
<h2 id="T3-练功"><a href="#T3-练功" class="headerlink" title="T3 练功"></a>T3 练功</h2><p>倒着处理的干活……</p>
<p>（太长太麻烦的题……）<del>我不是很想写</del></p>
<blockquote>
<p>小B有一台巨大的计算机，每当输入一个整数，这台计算机就会输出一个整数。为了理清这台庞大计算机的结构，小B将这台计算机的计算过程分为n个函数，每一个函数都有一个参数s，一开始第i个函数的参数为i 。 </p>
<p>对于一个带有参数s的函数，如果输入的数为x，那么它会实现以下过程： </p>
<p>1.如果x不为s的倍数，则将x加1。 </p>
<p>2.如果x为s的倍数，那么返回 x+s，函数结束。 </p>
<p>每一个函数输出的数将会成为下一个函数输入的数，计算机输出的数即为第n个函数的返回值。 </p>
<p>但光是这样并不能真正发挥这台计算机的强大功能，小B希望你能够帮他实现两个操作：</p>
<p><em>1.</em> <strong>l  r</strong> : 将第<strong>l</strong>个函数到第<strong>r</strong>个函数翻转，注意参数连同函数一起翻转。 </p>
<p><em>2.</em> <strong>st  c</strong> : 当从第<strong>st</strong>个函数输入一个<strong>c</strong>时，求整个计算机输出的值为多少？</p>
<p>$0≤c≤min(n^2,10^12);1≤st≤n;1≤l≤r;1≤n≤3*10^6;1≤q≤3000$</p>
</blockquote>
<p>听说这个东西要用到整除分块（啊其实还是听youwike说的）</p>
<p>推 <del>手膜</del> 了20分钟，弄出来一个性质：（在不进行反转的情况下）在进行了一定次数之后，我们输出的结果和我们当前的数的商，在一个区间内不变，可以合并（用整除分块）</p>
<p>翻转的情况：</p>
<p>我们可以对一个单调递增，递减的序列进行维护，每一次翻转都只会增加两个新区间</p>
<p>我们考虑对于一个原来的区间：[L,R]，如果我们输入的是$c_1$,输出的是$c_2$，那么意味着：反转之后输入的是$-C_2$输出的是$-C_3，C_3$是不比$C_1$小的第一个能够被R整除的数</p>
<p>那么我们倒推，如果第i+1个函数增加x次，那么第i个函数大概会增加$\frac{i+1}{i}*x$次</p>
<p>也可以进行合并处理所有$\frac{x}{i}$相等的项，种类数不超过20000种（然而我并不会证明）</p>
<h1 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h1><p>只会T1</p>
<h2 id="T1-拆分"><a href="#T1-拆分" class="headerlink" title="T1 拆分"></a>T1 拆分</h2><blockquote>
<p>现有一整数 <em>n</em>，求满足以下条件的整数序列个数：</p>
<p>• $a_1 + a_2 + · · · + a_m = n$ </p>
<p>• $0 &lt; a_1 ≤a_2 ≤ · · · ≤a_m$ </p>
<p>• $∀i\neq j~~|a_i-a_j|\ge k$ </p>
<p>• $h_m~ mod~ p = 1$</p>
<p>$1 ≤ n ≤ 10^6, 0 ≤ k ≤ n, 1 ≤ p ≤ k + 1$</p>
</blockquote>
<p><strong>啊我只会90分的做法</strong></p>
<p>我们看题可以知道，这个序列是递增的，相邻两个数之间的差至少为k</p>
<p>那么我们考虑一个dp：数的划分</p>
<p>由于每两个数之间的差至少为k，那么我们先将所有的数减去相应的k*(i-1)</p>
<p>最后被减去的就是$i*(i-1)*k/2$</p>
<p>观察发现，如果k&gt;0的话，i绝对不会超过$2*\sqrt{n}$的</p>
<p>所以最后复杂度就是$n*\sqrt{n}$级别（k=0的时候就是$n^2$</p>
<p>那么我们进行dp：</p>
<p>设$f[i][j]$表示前i个数，总和为j，那么我们可以认为$f[i][j]$可以通过$f[i-1][j-1],f[i][j-i]$转移过来</p>
<p>含义是：我们在这个序列的最后一位上添加上一个1或者将这个数列的所有数+1，事实证明可以遍历所有情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> scan</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>())</span><br><span class="line">            f |= c == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>())</span><br><span class="line">            x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>);</span><br><span class="line">        <span class="keyword">if</span> (f)</span><br><span class="line">            x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">read</span>(x), <span class="built_in">read</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">short</span> st[<span class="number">30</span>], tp;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            st[++tp] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x);</span><br><span class="line">        <span class="keyword">while</span> (tp)</span><br><span class="line">            <span class="built_in">putchar</span>(st[tp--] | <span class="number">48</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> scan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MOD</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; mod)</span><br><span class="line">        x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, k, p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = <span class="number">1</span>; i * (i - <span class="number">1</span>) * k / <span class="number">2</span> + i &lt;= n; i++, now ^= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i * (i - <span class="number">1</span>) * k / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[now], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f[now]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + x &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MOD</span>(f[now][j] = (f[now][j - i] + f[now ^ <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h[i % p])</span><br><span class="line">            ans += f[now][n - x], <span class="built_in">MOD</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-集合"><a href="#T2-集合" class="headerlink" title="T2 集合"></a>T2 集合</h2><p>值域扫描线一类的东西，题解没看懂……</p>
<h2 id="T3-网格"><a href="#T3-网格" class="headerlink" title="T3 网格"></a>T3 网格</h2><p>稳定匹配（等我把网络流搞完）</p>
<h1 id="2-24-（这两天太难了水了一会）"><a href="#2-24-（这两天太难了水了一会）" class="headerlink" title="2.24 （这两天太难了水了一会）"></a>2.24 （这两天太难了水了一会）</h1><p>一道都不会……</p>
<p>吐槽出题人太喜欢甘雨了。。。出了三道甘雨</p>
<h2 id="T1-藏弓待用"><a href="#T1-藏弓待用" class="headerlink" title="T1 藏弓待用"></a>T1 藏弓待用</h2><p>动态dp加分块优化空间</p>
<h2 id="T2-山泽麟迹"><a href="#T2-山泽麟迹" class="headerlink" title="T2 山泽麟迹"></a>T2 山泽麟迹</h2><p>树上的高斯消元……</p>
<h2 id="T3-降众天华"><a href="#T3-降众天华" class="headerlink" title="T3 降众天华"></a>T3 降众天华</h2><p>高斯整数gcd+平面几何</p>
<h1 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h1><p>（其实还没来得及改呢现在马上下课了）（再说了我也不会改啊）</p>
<h2 id="T1-给国与地震"><a href="#T1-给国与地震" class="headerlink" title="T1 给国与地震"></a>T1 给国与地震</h2><p>启发式合并？还是说可并堆一类的东西</p>
<h2 id="T2-给国与时光机"><a href="#T2-给国与时光机" class="headerlink" title="T2 给国与时光机"></a>T2 给国与时光机</h2><p>大构造。。。没听懂</p>
<h2 id="T3-给国与赌场"><a href="#T3-给国与赌场" class="headerlink" title="T3 给国与赌场"></a>T3 给国与赌场</h2><p>集训队学长表示不会做。。。甚至没看懂题解。。。</p>
]]></content>
      <tags>
        <tag>SCZ</tag>
      </tags>
  </entry>
  <entry>
    <title>群论</title>
    <url>/%E7%BE%A4%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="群论初步-学习笔记"><a href="#群论初步-学习笔记" class="headerlink" title="群论初步 学习笔记"></a>群论初步 学习笔记</h1><h2 id="群-定义"><a href="#群-定义" class="headerlink" title="群 定义"></a>群 定义</h2><p>一个集合被称为群当且仅当它满足以下四个条件：</p>
<ol>
<li><p>具有乘法封闭性，即：任意的$a,b\in G,a*b\in G$</p>
</li>
<li><p>具有结合律：$(a<em>b)<em>c=a</em>(b</em>c)$，左右乘是两个不一样的定义</p>
</li>
<li><p>具有幺元e：对于任意的$a\in G$都有$e<em>a=a,a</em>e=a$还是，左右乘定义并不一样</p>
</li>
<li><p>具有逆元：即：对于任意的$a\in G$ 都存在一个inv使得$a<em>inv=e,inv</em>a=e$</p>
</li>
</ol>
<p>普通的以$*$代指</p>
<p>然而还有另外的就是：一个群并不一定满足交换律 ，但是存在着满足交换律的群，我们称之为Abel群运算符号以$+$代指，幺元记为0</p>
<ol start="5">
<li>子群:群G的子集H满足上述四条公理那我们们称之为群G的子群，因此：H$\le$G，并且幺元不变</li>
</ol>
<p>陪集分解：群G，子群H，$g\in G$，$gH$为左陪集，$Hg$为右陪集</p>
<p><strong>子群检验法</strong>（subgroup test）是群G的子集H是子群的充分必要条件：对于所有元素$g\in G,h\in H$只需检查$g^{-1}\cdot h\in H$ 。</p>
<p>引理：对于任意的$h\in H,g\in G~g\cdot H=g\cdot h\cdot H$</p>
<p>任意两个陪集aH，bH满足以下两个条件之一</p>
<ul>
<li>aH=bH</li>
<li>$aH\cap bH =\phi$  </li>
</ul>
<ol start="6">
<li><p>拉格朗日定理：对于任意的$g\in G |gH|=|H|,|H|整除于|G|$</p>
<p>一个群进行陪集分解之后得到的子群个数为$[G:H]$，称为H的指数</p>
<p>$|G|=[G:H]|H|$</p>
</li>
<li><p>对称群/置换群：对于一个集合，我们将其中的元素都用一个${1…|G|}$中的数映射，这些映射是会在复合意义下构成一个群的。记为$S_n$ 以$(a_1,a_2…a_n)$代指这个群中的元素，对称群的映射是可以构成若干个并不会相交的环的叫做轮换</p>
</li>
<li><p>群作用：群G和集合X，G*X表示任意的$g\in G~x\in X$二元组$(g,x)$​构成G和X的笛卡尔积。是满足结合律的，</p>
<p>满足两个条件：$1_G<em>x=x,\forall x\in X$,$g_1</em>(g_2<em>x)=(g_1</em>g_2)*x,\forall g_1,g_2\in G,x\in X$</p>
<p>几个例子：</p>
<ul>
<li><p> ⽐如$S_n ↷ {1,2, ⋯ , ;}$。 </p>
</li>
<li><p>再⽐如$G ↷ G$，G对⾃⾝的左乘作⽤。</p>
</li>
<li><p>再⽐如$D_n ↷ {ํ有标号的正n边形}$。</p>
</li>
<li><p>设L为有标号的正四⾯体，则有：</p>
</li>
<li><ul>
<li>$Isom^+(T)↷ T$; </li>
</ul>
</li>
<li><ul>
<li>$Isom(T)↷T$ ;</li>
</ul>
</li>
</ul>
</li>
<li><p>轨道：首先我们定义一个二元关系：$x-y$（不是减号）就相当于是$\exists g\in G ~gx=y$。这个二元关系显然是一个等价关系（两边同乘逆元），这二元关系一定要满足某一些性质就比如:   </p>
<ul>
<li><p>这个二元关系要满足自自相关 </p>
</li>
<li><p>$A-B,B-A$两个是需要相互满足的 </p>
</li>
<li><p>$A-B,B-C那么C-B$，传递性。那么轨道就是指这个二元关系传递下去之后所形成的一个类似于等价类的东西</p>
<p> 所以x所在的等价类记为$G_x = O_x = {ax|a ∈ G}$，称为x的轨道</p>
<p>若X只有一个G轨道，则称G在X上的作用传递或可迁</p>
</li>
<li><p>稳定化子：$G_x=Stab_G(x)=(a\in G:ax=x)$成为x的稳定化子，易见Stab(x)是G的一个子群.</p>
<ol>
<li><p><strong>幺元</strong>必定在其中</p>
</li>
<li><p>$a,b\in Stab_G(x),a<em>b\in Stab_G(x)$。所以*<em>乘法封闭</em></em></p>
</li>
<li><p>$1*x=x,g^{-1}<em>g</em>x=g^{-1}x$所以<strong>逆元</strong>也在</p>
<p>证毕</p>
</li>
</ol>
</li>
</ul>
<p>引理：$\forall x\in X,g\in G,Stab_g(gx)=gStab_G(x)g^{-1}$</p>
</li>
<li><p>轨道-稳定化子定理：现设有群作用$G↷X$,则$|O_x|=[G:Stab_G(x)]$,进而有$|G|=|Stab_G(x)||O_x|$</p>
<p>证明:</p>
<p>设$H=Stab_G(x)&lt;=G$那么我们做G的H-陪集分解：</p>
<p>$G=a_1H\bigcup a_2H\bigcup a_3H\bigcup…\bigcup a_kH$</p>
<p>则：$O_x=a_1Hx\bigcup a_2Hx\bigcup a_3Hx\bigcup…\bigcup a_kHx={a_1x,a_2x,a_3x,…,a_kH}$</p>
<p>故：$|O_x|=k=[G:H]=[G:Stab_G(x)]$</p>
<p>由$|G|=|Stab_G(x)|[G:Stab_G(x)]$有$|G|=|O_x||Stab_G(x)|$</p>
</li>
</ol>
<h2 id="Burnside’s-Lemma"><a href="#Burnside’s-Lemma" class="headerlink" title="Burnside’s Lemma"></a>Burnside’s Lemma</h2><blockquote>
<p>定义：设有群作用$G↷ X$ ，则X内的G-轨道数为G中元素的平均不动点个数，即：$\frac{1}{|G|}\sum_{g\in G}|X^g|$,其中，$X^g$表示X在g下的不动点，即：{$x\in X:gx=x$}</p>
</blockquote>
<p>例子：现在有个正6边形，需要给每个顶点着⾊，问在旋转同构意义下有多少本质不同的着⾊⽅案。</p>
<p>我们明确一下我们的群：{$0\degree,60\degree,120\degree,180\degree,240\degree,300\degree$}</p>
<p>所有的染色方法应该是$2^6$，在旋转$60\degree$的时候应该有一个轨道，就是两种染色方案，120的时候两个轨道，180时3个，240时2个，300时1个，所以总共应该是$\frac{64+2+4+8+4+2}{6}=14$种</p>
<h2 id="Polya’s-theorem"><a href="#Polya’s-theorem" class="headerlink" title="Pólya’s theorem"></a>Pólya’s theorem</h2><p>具体⽽⾔， $G\le S_n$对于G ↷ {1,2, ⋯ , ;}并且给{1,2, ⋯ , ;}着⾊这种问题，假设颜⾊数为c，则对⼀个排列{$a_i$}来说，记它的轮换个数为k，则它的不动点个数为$c^k$)。  </p>
<p>事实上，任意⼀个⼤⼩为n的群都同构于$s_n$的⼀个⼦群。（Cayley定理，考虑左乘作⽤)。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="容斥-先鸽着吧"><a href="#容斥-先鸽着吧" class="headerlink" title="容斥 先鸽着吧"></a>容斥 <del>先鸽着吧</del></h2><h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><p>常用公式：</p>
<h5 id="1-N-choose-K-N-K-N-K"><a href="#1-N-choose-K-N-K-N-K" class="headerlink" title="1.$ {N \choose K}=N!/(K!*(N-K)!)$"></a>1.$ {N \choose K}=N!/(K!*(N-K)!)$</h5><h5 id="2-sum-i-0-N-N-choose-I-2-N"><a href="#2-sum-i-0-N-N-choose-I-2-N" class="headerlink" title="2.$ \sum_{i=0}^{N}{N \choose I}=2^N$"></a>2.$ \sum_{i=0}^{N}{N \choose I}=2^N$</h5><h5 id="3-sum-i-0-N-N-choose-i-1-i-0"><a href="#3-sum-i-0-N-N-choose-i-1-i-0" class="headerlink" title="3.$\sum_{i=0}^{N}{N\choose i}(-1)^i=0$"></a>3.$\sum_{i=0}^{N}{N\choose i}(-1)^i=0$</h5><h5 id="4-sum-N-i-0-N-choose-i-x-i-1-x-N"><a href="#4-sum-N-i-0-N-choose-i-x-i-1-x-N" class="headerlink" title="4.$\sum_{N}^{i=0}{N\choose i}x^i=(1+x)^N$"></a>4.$\sum_{N}^{i=0}{N\choose i}x^i=(1+x)^N$</h5><h5 id="5-范德蒙公式：-sum-i-0-K-N-choose-i-M-choose-K-i-N-M-choose-K-sum-i-0-M-N-choose-i-M-choose-i-sum-i-N-choose-i-M-choose-M-i-N-M-choose-M"><a href="#5-范德蒙公式：-sum-i-0-K-N-choose-i-M-choose-K-i-N-M-choose-K-sum-i-0-M-N-choose-i-M-choose-i-sum-i-N-choose-i-M-choose-M-i-N-M-choose-M" class="headerlink" title="5.范德蒙公式：$\sum_{i=0}^{K}{N\choose i}{M\choose K-i}={N+M\choose K}$        $\sum_{i=0}^{M}{N\choose i}{M\choose i}=\sum_{i}{N\choose i}{M\choose M-i}={N+M\choose M}$"></a>5.范德蒙公式：$\sum_{i=0}^{K}{N\choose i}{M\choose K-i}={N+M\choose K}$        $\sum_{i=0}^{M}{N\choose i}{M\choose i}=\sum_{i}{N\choose i}{M\choose M-i}={N+M\choose M}$</h5><h5 id="6-重要：-N-choose-K-K-choose-i-N-choose-i-N-i-choose-K-i"><a href="#6-重要：-N-choose-K-K-choose-i-N-choose-i-N-i-choose-K-i" class="headerlink" title="6.重要：${N\choose K}{K\choose i}={N\choose i}{N-i\choose K-i}$"></a>6.重要：${N\choose K}{K\choose i}={N\choose i}{N-i\choose K-i}$</h5><p>理解：N个里选出来K个，再从K个之中选出i个，就相当于是在我的N中先选出来i个，再从剩下的N-i个之中选出来K-i个</p>
<p>经典场景：$\sum_k\sum_if(i){N\choose K}{K\choose i}=\sum_if(i)\sum_K{N\choose i}{N-i\choose K-i}=\sum_if(i){N\choose i}2^{N-i}$</p>
<h5 id="7-帕斯卡公式：-N-choose-i-N-1-choose-i-1-N-1-choose-i"><a href="#7-帕斯卡公式：-N-choose-i-N-1-choose-i-1-N-1-choose-i" class="headerlink" title="7.帕斯卡公式：${N\choose i}={N-1\choose i-1}+{N-1\choose i}$"></a>7.帕斯卡公式：${N\choose i}={N-1\choose i-1}+{N-1\choose i}$</h5><p>然后就可以推出来：${N+1\choose K+1}=\sum_{i=K}^{N}{i\choose K}$</p>
<p>​    等价的:${N+1\choose K+1}=\sum_{i=K}^{N}{i\choose i-K}$（要对这个公式敏感一点）</p>
<p>这个公式有一个巧记的方法：</p>
<p>我枚举一个i，想象我选的第一个数是第i个，那么我还剩下N-i个物品，我要在这N-i个物品中选取K个，根据加法原理进行加和，就得出了这一个公式</p>
<p>另一种利用：$\sum_{i=0}^{K}{N+1\choose i}=\sum_i{N\choose i}+{N\choose i-1}=2\sum_{i=0}^{K}{N\choose i}-{N\choose K}$</p>
<p>可以运用杨辉三角形进行理解：上一行的所有数都向下产生了两倍于自己的贡献值，除了最后一个之外，所以我乘以二再减去末尾</p>
<p>似乎是另一种变形：$\sum_{k&lt;=n}{r+k\choose k}={r\choose 0}+{r+1\choose 1}+···+{r+n\choose n}={r+n+1\choose n}$，其实相当于上面的那个等价帕斯卡公式</p>
<p>另一种名字叫做<strong>关于上指标求和</strong>，$\sum_{0&lt;=k&lt;=n}{k\choose m}={n+1\choose m+1},m,n&gt;=0$</p>
<p>这两个个已通过对称性进行相互推出</p>
<h5 id="8-重要的一个东西：二项式定理：-x-y-r-sum-k-r-choose-k-x-ky-r-k-整数r-gt-0或者-x-y-lt-1"><a href="#8-重要的一个东西：二项式定理：-x-y-r-sum-k-r-choose-k-x-ky-r-k-整数r-gt-0或者-x-y-lt-1" class="headerlink" title="8.重要的一个东西：二项式定理：$(x+y)^r=\sum_{k}{r\choose k}x^ky^{r-k}$整数r&gt;=0或者$|x/y|&lt;1$"></a>8.重要的一个东西：二项式定理：$(x+y)^r=\sum_{k}{r\choose k}x^ky^{r-k}$整数r&gt;=0或者$|x/y|&lt;1$</h5><p>这个东西的很多特殊值是非常有用的比如1+1,1+(-1)一类的，可以用来推式子(比如容斥呀容斥呀容斥呀什么的……)</p>
<p>上面前几条性质都是二项式定理的特殊值，所以二项式定理还是很好用的……</p>
<p>推论：$0^n={n\choose 0}-{n\choose 1}+…+(-1)^n{n\choose n},n&gt;=0$ (有一道题告诉我：同一行的（也就是上指标一样的）奇数二项式之和等于偶数二项式之和)（洛谷P5390数学作业，一个小绿题我做了老半天做不出来太恶心了）<a href="https://www.luogu.com.cn/problem/P5390">题目</a></p>
<h5 id="9-负数二项式：对于取负数值的n和取正数值的n，其-n-choose-k-之间有一种联系，一般的规则是："><a href="#9-负数二项式：对于取负数值的n和取正数值的n，其-n-choose-k-之间有一种联系，一般的规则是：" class="headerlink" title="9.  负数二项式：对于取负数值的n和取正数值的n，其${n\choose k}$之间有一种联系，一般的规则是："></a>9.  负数二项式：对于取负数值的n和取正数值的n，其${n\choose k}$之间有一种联系，一般的规则是：</h5><p>$$<br>{r\choose k}=(-1)^k{k-r-1\choose k}<br>$$</p>
<p>我们称之为：<strong>反转上指标</strong></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
