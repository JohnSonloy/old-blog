<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1613</title>
    <url>/1613/</url>
    <content><![CDATA[<p>P1613 跑路 一道小绿题<br>虽然这只是一道小绿题但是我觉得还是有必要总结一下的因为不错</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有辆很 n i u b i 的汽车一秒钟可以跑2的任意整次方的距离<br>给你一个有向图问：从1跑到n最短时间（边权都是1）</p>
<h1 id="先给一会思考一下"><a href="#先给一会思考一下" class="headerlink" title="先给一会思考一下"></a>先给一会思考一下</h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，题目描述就让我们很容易想到倍增这个算法<br>我们需要把所有的边都存起来<br>但是一个问题是，在有向图上倍增……会炸……<br>很容易想到如果我们进行倍增，图并不支持随机访问（不是树）显然要一个一个跳，一定会炸<br>所以：一个dp的思路就出来了（严格意义上的dp，但不严格意义上我一般不把他算作dp）<br>就是<strong>floyd</strong><br>我们考虑倍增的思想：如果我从p点走2^n-1 到另一个点，再从另一个点走2^n-1 可以走到q点，那就说明我们可以p-&gt;q走2^n距离（就是1秒）<br>那么，我们再运用floyd的思路，如果j到i，i到k都是1秒，那么j到k就是1秒<br>我们只需要再floyd的三重循环外面加一个循环对倍增的那一维进行判断就可以了<br>floyd之后：<br>我们已经求出了那个点到那个点是1的距离，但显然我们可能不会起点到终点一定是1s<br>所以我们需要跑最短路<br>在floyd求得dis数组的基础上，跑一遍最短路，就是最后的最短时间</p>
<h1 id="代码时间"><a href="#代码时间" class="headerlink" title="代码时间"></a>代码时间</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 70</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        f[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dis[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= <span class="number">64</span>; u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (f[j][i][u - <span class="number">1</span>] &amp;&amp; f[i][k][u - <span class="number">1</span>])</span><br><span class="line">                        f[j][k][u] = <span class="number">1</span>,</span><br><span class="line">                        dis[j][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                dis[j][k] = <span class="built_in">min</span>(dis[j][k], dis[j][i] + dis[i][k]);</span><br><span class="line">    cout &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒花<br>还蛮有意思的一道题……</p>
]]></content>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA</title>
    <url>/LCA/</url>
    <content><![CDATA[<h1 id="最近公共祖先LCA-洛谷P3379"><a href="#最近公共祖先LCA-洛谷P3379" class="headerlink" title="最近公共祖先LCA 洛谷P3379"></a>最近公共祖先LCA 洛谷P3379</h1><h2 id="今天xiao习了一下LCA过程十分曲折。。。"><a href="#今天xiao习了一下LCA过程十分曲折。。。" class="headerlink" title="今天xiao习了一下LCA过程十分曲折。。。"></a>今天xiao习了一下LCA过程十分曲折。。。</h2><p>（检查的时候主函数没有调用dfs，调试了好几遍才发现。。。<br>首先，我们先来看一看定义：最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。<br>它有三种做法：</p>
<ol>
<li>暴力 </li>
<li>倍增 </li>
<li>树链剖分<br>遗憾的是我就会前两种；<h2 id="第一种枚举"><a href="#第一种枚举" class="headerlink" title="第一种枚举"></a>第一种枚举</h2>我们有了这么一棵树，和其中的两个节点；那么我们只需要一个一个求出它们的祖先，一步步向上跳就可以找到交点，找到第一个交点就是最近公共祖先<br>显而易见，这是最为朴素的正解；<br>但不是最优解；<br>仔细一想就知道他可顶复杂度超高（给两个叶子结点最后回到根上）<br>明显过不去<br>那么就要想方设法优化<h2 id="第二种方法-倍增"><a href="#第二种方法-倍增" class="headerlink" title="第二种方法 倍增"></a>第二种方法 倍增</h2>倍增求LCA是最经典的方法了（不要问我谁提出来的问就是不知道）<br>上面朴素做法是一步一步向上跳，那么我们就可以很多步很多步向上跳，就可以优化；<br>而倍增就是优化的方法之一，以logn的时间复杂度来向上查询<br>只需要预处理出一个数组f[u][i]u是节点，i是指u向上2^i个节点处（第2^i个祖先<br>那么我们就可以一步一步向上跳<h2 id="第三种方法-树链剖分"><a href="#第三种方法-树链剖分" class="headerlink" title="第三种方法 树链剖分"></a>第三种方法 树链剖分</h2>我不会。。。……以后再写<h2 id="上代码："><a href="#上代码：" class="headerlink" title="上代码："></a>上代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> next,v;</span><br><span class="line">&#125;cun[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],d[maxn],f[maxn][<span class="number">22</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cun[++tot].next=head[x];head[x]=tot;cun[tot].v=y;<span class="comment">//结构体存链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=d[fa]+<span class="number">1</span>;<span class="comment">//子节点深度是父节点加一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[u][i+<span class="number">1</span>]=f[f[u][i]][i];<span class="comment">//可以自己推导（就是乘个二</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=cun[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=cun[i].v;<span class="comment">//邻接表向后查询</span></span><br><span class="line">        <span class="keyword">if</span>(a==fa)<span class="keyword">continue</span>;<span class="comment">//不查询父节点</span></span><br><span class="line">        f[a][<span class="number">0</span>]=u;<span class="comment">//a是u的子节点，向上跳2^0是父节点u</span></span><br><span class="line">        <span class="built_in">dfs</span>(a,u);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);<span class="comment">//后面方便</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从后向前找，二进制拆分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];<span class="comment">//如果深度大就向上跳到相等为止</span></span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;<span class="comment">//如果同一深度时相等就相当于y是x的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i])<span class="comment">//向上跳不相等的话就向上跳</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];y=f[y][i];<span class="comment">//继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*由于向上跳容易误判，所以我们选择向上跳到同一父节点时停止，最后输出父节点</span></span><br><span class="line"><span class="comment">        向上跳无论如何都相等时就是同一父节点了*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];<span class="comment">//父节点便是LCA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        <span class="built_in">add</span>(x1,y1);</span><br><span class="line">        <span class="built_in">add</span>(y1,x1);<span class="comment">//无向图需要双向添加边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">LCA</span>(x1,y1)&lt;&lt;endl;<span class="comment">//直接输出返回的就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾声-Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q"><a href="#尾声-Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q" class="headerlink" title="尾声 Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q"></a>尾声 Johnsonloy的LCA过啦（以后会补全树链剖分的内容滴Q-Q</h2></li>
</ol>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>MST</title>
    <url>/MST/</url>
    <content><![CDATA[<h1 id="MST-最小生成树板子"><a href="#MST-最小生成树板子" class="headerlink" title="MST 最小生成树板子"></a>MST 最小生成树板子</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天对我的图论知识进行了一次的扩充，最小生成树<br>前言知识：并查集，可以去翻我的博客虽然还不完善但也有一点点的用途</p>
<h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>kruskal算法由kruskal发明（废话），本质思想是在两个最小联通块之间找到最小的边使得这两联通快之间合并代价最小（就是边权<br>所以，kruskal算法是一个贪心的做法<br>我们按照最小的边权一个一个加入，只要加入不产生环，就把这个点和这个边放进一个点集里<br>所以，不产生环。。。怎么做呢。。。<br>并查集咯。<br>很简单，再加入一条边的时候，就相当联通两个联通块，如果这两个联通块本来就是联合的，加入就会构成一个环<br>所以只要并查集查找这条边的两个点是不是已经被联通的了就好了<br>证明就是一个环中删掉最大的边的意思（差不多。。。可以去看OIWIKI<br><a href="https://oi-wiki.org/graph/mst/">https://oi-wiki.org/graph/mst/</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>P3366</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;bian[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mm p,mm q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.z&lt;q.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[p]==p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">find</span>(p);q=<span class="built_in">find</span>(q);</span><br><span class="line">    fa[p]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;bian[i].x&gt;&gt;bian[i].y&gt;&gt;bian[i].z;</span><br><span class="line">    <span class="built_in">sort</span>(bian+<span class="number">1</span>,bian+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(bian[i].x)!=<span class="built_in">find</span>(bian[i].y))</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=bian[i].z;</span><br><span class="line">            <span class="built_in">merge</span>(bian[i].x,bian[i].y);</span><br><span class="line">            <span class="keyword">if</span>(++num==n<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prim算法："><a href="#prim算法：" class="headerlink" title="prim算法："></a>prim算法：</h2><p>由于本人不是很会写prim，经常写的是kruskal。。。所以就不给放程序这种东西了。。。不过一些思路我还是会的<br>prim算法和kruskal异曲同工，不过，prim算法不是加边，而是加点<br>prim算法也是维护一个连通块<br>每次加进去一个距离自己最近的点，加入自己，在更新所有点的距离（重新更新<br>就像是dijkstra。。。每次找一个最近的去更新其他的节点距离<br>所以。。。它也能堆优化<br>不过就算是堆优化也没有kruskal跑的快<br>所以 建议使用kruskal</p>
<h2 id="最小生成树的延伸————次小生成树"><a href="#最小生成树的延伸————次小生成树" class="headerlink" title="最小生成树的延伸————次小生成树"></a>最小生成树的延伸————次小生成树</h2><p>次小生成树分为两种：不过差不多就是能不能等于<br>1.非严格次小生成树<br>边权和大于等于最小生成树</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/Tree/</url>
    <content><![CDATA[<h1 id="Tree-洛谷-P2619"><a href="#Tree-洛谷-P2619" class="headerlink" title="Tree 洛谷 P2619"></a>Tree 洛谷 P2619</h1><p>一道生成树的很好的题目</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。<br>乍一看还是很没有头绪的（反正刚开始我没有</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于我们需要求一个最小权的，恰好有need条边的生成树<br>首先可以想到一个贪心的作法就是我先把最小的白边加入生成树之中直到need条跑MST<br>再把黑边跑MST加入生成树中<br>但显然。。。这个贪心的策略非常不对。。。<br>因为白边的长度和加上黑边的长度和才会是总长度和，如果黑边要加入2条边，共有三条边，为1,2,99999……黑边是会影响到白边的选取的，所以我们需要从整体上考虑问题，考虑同时加入白边黑边的时候应该如何进行选取最优<br>那我们先跑一遍MST，求出加入的白边的个数此时加入的百变个数与need一定是有差别的（如果等于了直接输出就可以了）<br>我们想要从整体上考虑问题，那么我们就改变MST的过程就好了<br>但是怎么改变就是一个问题……<br>kruskar的过程是要进行排序的，那我们就……改变权值就可以了呀！<br>我们将白边的权值进行改变，在每次与need不相符的时候就进行一次改变权值，就可以进行对百变加入生成树的过程的改变<br>如果我们将白边的权值增大以至于最小的可以加入的次小黑边，就将那条黑边加入，把这条黑边弹出，这样我们是可以获得最小的取出一条白边的代价的（因为需要一点点增加）<br>所以正解思路就具备了</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现过程中，我们将白边的权值一点点的改变……<br>聪明的同学就想到了：<br>复杂度可能有点不对（然后开始diss我）<br>不要着急。。。题目中给定的边权是小于等于100的，我们进行二分就可以了呀<br>二分答案是一个很好的东西（虽然在这道题中不二分似乎也可以过去，我没有试验过，但是数据范围改一改就可以看到二分答案的优势了）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（由于是过了好长时间才回来写的博客所以有点生疏了）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> v,e,need;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,val,c;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a1,node a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a1.val==a2.val)<span class="keyword">return</span> a1.c&lt;a2.c;<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">return</span> a1.val&lt;a2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans,check;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;check=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v+<span class="number">1</span>;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+e,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;cnt!=v<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> aa=<span class="built_in">find</span>(a[i].u),bb=<span class="built_in">find</span>(a[i].v);</span><br><span class="line">        <span class="keyword">if</span>(aa!=bb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].c==<span class="number">0</span>)check++;<span class="comment">//白边</span></span><br><span class="line">            <span class="built_in">merge</span>(aa,bb);</span><br><span class="line">            ans+=a[i].val;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kruskal判断这一次进行MST后生成树的白边数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;e&gt;&gt;need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].val&gt;&gt;a[i].c;</span><br><span class="line">        a[i].u++;a[i].v++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">-105</span>,r=<span class="number">105</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val+=mid;</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">        <span class="keyword">if</span>(check&gt;=need)&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">            num=ans-need*mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">            <span class="keyword">if</span>(!a[i].c)a[i].val-=mid;</span><br><span class="line">        <span class="comment">//对要加的长度进行二分答案，最后的结果再减去白边所加上的权值和</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>app</title>
    <url>/app/</url>
    <content><![CDATA[<h1 id="我的第一篇博客ohhhhhh"><a href="#我的第一篇博客ohhhhhh" class="headerlink" title="我的第一篇博客ohhhhhh"></a>我的第一篇博客ohhhhhh</h1><p>今天cloudysky帮助了无助的森森创建了自己的博客；<br>当前的森森还是个小蒟蒻；<br>但是森森相信自己在不久后的将来；<br>会变成一个大蒟蒻而爆零；<br>凡王之血必以剑终；<br>以贱民之血染红白银的御座。<br>路明非啊路明非，就你荒废的那些时间，红军长征都走到苏联去了。<br>以前我也耸着肩膀缩着头，站在别人都不看我的角落里……那样没用的，不会让你觉得更好。就算在最难的时候，也要摆出一副我是开迈巴赫来的表情啊！<br>如果一个人心里藏了那么多的喜怒哀乐，一定曾经活得伤痕累累。<br>他想自己在她眼里出现的时候,璀璨如星辰。可即使有那么一天,他披挂着漫天的星辰归来,可是仰望天空的瞳孔已经不在,看星星的女孩已经走了,那璀璨又有什么意思呢?孤单得连星星也想坠落。<br>知道了吗，没有权与力你什么都不是，你本应是一个咆哮于世间的怪物，却甘愿收起爪牙当个废物          ——路明泽；<br>goodbye,johnsonloy l o y；</p>
]]></content>
      <tags>
        <tag>first-blog</tag>
      </tags>
  </entry>
  <entry>
    <title>P1827</title>
    <url>/shu/</url>
    <content><![CDATA[<h1 id="P1827-奶牛"><a href="#P1827-奶牛" class="headerlink" title="P1827 奶牛"></a>P1827 <strong>奶牛</strong></h1><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a><strong>题目解读</strong></h2><p>其实说到底就是一道树的后序遍历反推而已嘛<br>首先，让我们看一遍题目：<br>给了一棵树的前序中序遍历，让求出后序遍历；（习惯性的打出分号<br><a href="https://oi-wiki.org/graph/tree-basic/#_14%EF%BC%88%E9%99%84%E4%B8%8AOI-WIKI%E7%9A%84%E8%AE%B2%E8%A7%A3">https://oi-wiki.org/graph/tree-basic/#_14（附上OI-WIKI的讲解</a><br>首先我们知道前序遍历在开头是根节点，那么，就将根节点取出（用string可做到<br>那么，在中序遍历中找到根节点的位置，左边就是左子树，右边就是右子树<br>在左子树中，前序遍历的<strong>左半截</strong>的开头就是左子树的根节点，再将根节点取出，再在中序遍历的<strong>左半边</strong>寻找……<br>然后再在右子树中重新做一遍这个过程，<em>（注意）</em>重新做的时候也要从左子树开始做<br>！！！这是什么！！！<br>赤裸裸的递归啊<br>所以！就可以用一个递归小函数来解决这个问题</p>
<h2 id="另一件事情"><a href="#另一件事情" class="headerlink" title="** 另一件事情 **"></a>** 另一件事情 **</h2><p>在上述说明中呢，看上去非常的简单；<br>但是，上面提到了前序遍历的左半边，难道是说要在存一个string做吗；<br>是的，需要————<br>但是不要惊慌<br>接下来我要说的就是string的库函数之一：substr()；<br>substr(本质上是复制字符串的一部分放入新的字符串之中；<br>就省得孩子们一遍遍的for了</p>
<h2 id="上代码："><a href="#上代码：" class="headerlink" title="** 上代码：**"></a>** 上代码：**</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string aa,string bb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa.<span class="built_in">empty</span>())<span class="keyword">return</span>;       <span class="comment">//这是在判断边界</span></span><br><span class="line">    <span class="keyword">char</span> root=aa[<span class="number">0</span>];        <span class="comment">//将前序遍历的根节点取出来</span></span><br><span class="line">    <span class="keyword">int</span> k=bb.<span class="built_in">find</span>(root);        <span class="comment">//找到根节点</span></span><br><span class="line">    aa.<span class="built_in">erase</span>(aa.<span class="built_in">begin</span>());       <span class="comment">//将根节点从string中删除</span></span><br><span class="line">    string laa=aa.<span class="built_in">substr</span>(<span class="number">0</span>,k),raa=aa.<span class="built_in">substr</span>(k),lbb=bb.<span class="built_in">substr</span>(<span class="number">0</span>,k),rbb=bb.<span class="built_in">substr</span>(k+<span class="number">1</span>);       <span class="comment">//激动人心的拆卸时间</span></span><br><span class="line">    <span class="built_in">dfs</span>(laa,lbb);<span class="built_in">dfs</span>(raa,rbb);      <span class="comment">//遍历</span></span><br><span class="line">    cout&lt;&lt;root；         <span class="comment">//由于是后序遍历所以最后输出根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">dfs</span>(b,a);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a><strong>尾声</strong></h2><p>森森的第一篇学术博客结束</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天根据书上的指引，想要学习最小生成树，然而蒟蒻在OI WIKI上学习的时候被告知：<br>前置章节是并查集。。。<br>于是蒟蒻便用了一天的时间A了三道黄题一道蓝题（其实相当于一道黄题……<br>所以今天蒟蒻过来总结一番</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集是一种树形结构，通过名字我们可以知道：<br>并：合并，查：查询，集：集合<br>就是合并和查询一个集合<br>也可以相当于是联通块之间的判断。<br>我们把一个联通快之间的点放入一个点集之中，<br>并查集就可以查询这个点是不是在集合中（不知道集合的去预（复）习高一课本</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们看一个故事：<br>几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。<br>（来自于OI WIKI）<br>我们的并查集就相当于是这个故事中的实现过程：<br>建立一棵树，将父亲自己的儿子放进儿子节点中<br>每次询问两个人是在哪一个家族（树）之中，就询问自己的父亲是否在家族（树）之中<br>如果两个人的某个祖先（c++意义上）相等，就相当于他们两个是在一个家族中的<br>但是，有一次，两个祖先对话，想将各自的家族合并到一起，这该怎么办。。。<br>好办！将一个祖先的爸爸改成另一个祖先就可以了，反正我们不在乎某一个节点的爸爸究竟是谁，显然我们只在乎两个人是否是同一个家族也就是需不需要去一(de)起(guo)祭(gu)拜(ke)。</p>
<h2 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h2><p>查找：<br>就像上述操作一样，建立一棵树，将某些儿子们放进并查集，访问就可以知道是那颗树<br>合并：<br>也像上面一样，改父亲<br>在最开始的时候，我们是不知道谁是谁的爸爸的，那么就让他们每一个人都是一个小家族，当我们知道了谁是谁的爸爸之后，进行一次合并操作，就可以让两个人变成同一个祖先<br>但是，如果每一次查找都要向上跳到最上面的祖先或者每一次合并都需要合并n/2个点，那么复杂度将会是巨大的。。。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩，顾名思义，就是将并查集查询的路径进行压缩<br>我们上面说到了，每一次查找都需要向上进行跳跃，一直跳到祖先一样（其实一般都需要直接爬到最上面<br>这样的复杂度真的很大<br>定义中说的是：我们要判断联通块，那么我们就把所有的儿子节点直接连向树根<br>之后再去判断就只需要O（1）时间查询祖先了（虽然在预处理的时候不是O1但也快了不少</p>
<h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>说实话我不知道为什么要去这个名字，感觉很难受并且我找不到名字和操作之中的关系<br>上面有说到，我们在合并的时候，是要将一个祖先改成另一个祖先的儿子的<br>那么如果n个点，n-1个点是一个集合，1个点是一个集合，我们将它合并，要把n-1个点的爸爸都改一改，会很累<br>但如果我们把1个点的祖先更改，就会很简单的呢！（假装很厉害的样子<br>所以，每一次我们进行合并之前，都记录一下联通块的点数<br>每一次合并取一次min，就会优化</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>其实启发式合并有没有无所谓，有的时候还可能增加你的时间复杂度（其实可能就是一个常数<br>在不用启发式合并只用路径压缩的复杂度其实也就是mlogn甚至说ma(m,n)。。。<br>（所以我不会写启发式合并</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码就以洛谷的板子了P3367</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="comment">//父节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionset</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    fa[x]=y;<span class="comment">//祖先的更改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="comment">//初始化，自己是一个小家族</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionset</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))cout&lt;&lt;<span class="string">&#x27;Y&#x27;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&#x27;N&#x27;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常的简单。。。<br>我反正是这么觉得的。。。<br>时间复杂度：<a href="https://oi-wiki.org/ds/dsu-complexity/">https://oi-wiki.org/ds/dsu-complexity/</a></p>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>其实带权并查集和普通的并查集没有什么太大的不同，只是在我们每一次改变权值的时候都改一下到根节点的距离罢了<br>（其实我也不会，明天学会再改博客）</p>
<h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><p>（不会，以后再说。。。）<br>（这种东西应该是要在以后重新发博客的。。。如果你以后在我的博客之中翻到了。。。就不要让我回来改博客了。。。很累的。。。）</p>
<h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>NOI2015 程序自动分析<br>JSOI2008 星球大战<br>NOI2001 食物链<br>NOI2002 银河英雄传说<br>UVA11987 Almost Union-Find</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>最小生成树（马上要去写）和LCA最近公共祖先（写完了，可以看）</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>很大一部分借鉴了OI WIKI<br>侵权勿喷。。。（我非盈利aaa<br>good bye</p>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="对前缀和与差分进行总结，来源：洛谷题单"><a href="#对前缀和与差分进行总结，来源：洛谷题单" class="headerlink" title="对前缀和与差分进行总结，来源：洛谷题单"></a>对前缀和与差分进行总结，来源：洛谷题单</h1><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>（由于之前教练和我说可以刷一刷洛谷的题单刷刷基础我就去了</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前缀和有几种，一维和二维的用的比较多。"><a href="#前缀和有几种，一维和二维的用的比较多。" class="headerlink" title="前缀和有几种，一维和二维的用的比较多。"></a>前缀和有几种，一维和二维的用的比较多。</h2><p>一维前缀和比较简单，直接将数组的前几个加起来成一个单独的数组就可以<br>二维前缀和有点不一样：我们的二维前缀和处理的过程中不能直接通过上一个得到（需要三步操作其实也相当于直接得到。。。<br>在进行循环的时候，我们可以设想一下：<br>1 2 3<br>1 2 3<br>1 2 3<br>的前缀和f[2][3]等于什么<br>显然它可以从f[2][2]和f[1][3]转移过来<br>但是都不一样f[2][2]+f[1][3]会把f[1][2]算两次<br>所以……减一下就可以<br>方程：f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1];<br>就可以进行处理了</p>
<h3 id="二维前缀和的例题：洛谷P2004-领地选择"><a href="#二维前缀和的例题：洛谷P2004-领地选择" class="headerlink" title="二维前缀和的例题：洛谷P2004 领地选择"></a>二维前缀和的例题：洛谷P2004 领地选择</h3><p><a href="https://www.luogu.com.cn/problem/P2004">题目链接</a><br>一道模板题。。。<br>处理二维前缀和，四个角顶点x1,x2,y1,y2(x1&lt;x2,y1&lt;x2)ans=max(ans,f[x2][y2]-f[x1][y2]-f[x2][y1]+f[x1][y1]);<br>怎么推导意会一下就可以很简单</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分是一种很妙的算法，有的时候他可以自己单独成题，有的时候也可以配合着前缀和<br>因为：前缀和与差分是一对逆操作，前缀和序列差分一下就是原序列，差分序列前缀和一下也是原序列</p>
<h3 id="例题1-IncDec-Sequence-CH0304（简称：蓝书例题）"><a href="#例题1-IncDec-Sequence-CH0304（简称：蓝书例题）" class="headerlink" title="例题1 IncDec Sequence CH0304（简称：蓝书例题）"></a>例题1 IncDec Sequence CH0304（简称：蓝书例题）</h3><p>给定一个长度为n(1e5)的序列，每次可以选择一个区间+1或者-1<br>求至少多少次可以让序列所有数相等，再求，最少次数之下，序列最后多少种可能的值<br>序列所有数都相等代表了：差分序列除了第一个之外都为0<br>那么：我们让差分序列b的bn+1=0，每一次进行区间加减的时候都代表着我们要对差分序列中的两个数一个+1另一个-1；<br>我们的目的是让b2~bn变成0.<br>由于加一减一都是可以的，那么我们就没有区间进行加减时是否需要考虑+1在前还是-1在前这个限制了<br>（之前考试的时候有一道题是只给减法的，就比这个难一点，但其实也就相当于是特判，不难）<br>我们可以进行分类讨论：<br>1.选bi,bj，在一个正另一个负的时候多进行操作<br>2.选b1,bj，1选完之后考虑<br>3.选bi,bn+1，同样是1选完之后考虑<br>4.b1,bn+1，没有意义，舍去（因为b1,bn+1并不会对序列造成影响<br>第1类操作我们可以直接进行判断，判断序列中正数负数的绝对值，这两个的差就是1的次数<br>而第二第三次直接判断剩下的就可以，因为2，3操作事实上等价<br>综上所述，这个题第一问的答案就是两个数绝对值最大的那个（正负数分别的和的max）<br>而第二问：因为是要求最小次数，操作一的次数等无影响，反正都会消耗完<br>那就考虑第2,3次操作的次数<br>如果我们第2,3次操作次数为m<br>我们就可以进行选择进行那次操作，每次选择操作会不一样，但既然是问值，那就询问差分序列的第一个值<br>考虑操作2，每一次的操作2都会对b1进行更改，操作2至少0次，最多m次，共m+1中可能<br>m=max(p,q)-min(p,q)<br>完美解决。。。</p>
<h3 id="例题2-洛谷P2671-求和"><a href="#例题2-洛谷P2671-求和" class="headerlink" title="例题2 洛谷P2671 求和"></a>例题2 洛谷P2671 求和</h3><p>前缀和好题<br><a href="https://www.luogu.com.cn/problem/P2671">题目链接</a><br>我们先考虑题中给的三元组（x,y,z）<br>y-x=z-y那么说明，x,z同奇或者同偶<br>既然如此，我们考虑对color下手：<br>每一个color的奇数偶数分别存储，他们中的每一个都可以单独构成一个三元组<br>三元组的分数：<br>编号之和乘数字之和<br>如果一个一个找，复杂度会炸<br>那么我们就可以看看这个分数能不能下手：显然可以<br>(x+z)<em>(numx+numz)=x</em>numx+z<em>numx+numz</em>x+z<em>numz<br>在每一个三元组，我们的x</em>numx都会被算到，那就统计一下三元组的个数，运用结合律把这么多的三元组进行结合律<br>我们数列中的元素回合所有其他的元素构成一个三元组从而被算一次（不管比他小还是比他大）<br>元素还会和其他元素的num都乘一次<br>那么我们处理cnt数组（就是记录color奇数偶数的那个）乘奇偶数的前缀和减去当前的数加上cnt数组乘当前的数字<br>这道题就被巨佬的您切掉了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之前缀和与差分是可以用到很多的地方的<br>插粉还可以用在你自己想要的区间求和<br>比如你想让一段序列都加都减，直接在差分序列上改一改最后求一个前缀和就可以了<br>很nice</p>
<h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="被迫营业，学习了树状数组"><a href="#被迫营业，学习了树状数组" class="headerlink" title="被迫营业，学习了树状数组"></a>被迫营业，学习了树状数组</h1><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="粗："><a href="#粗：" class="headerlink" title="粗："></a>粗：</h2><p>树状数组是一个基于二进制的数据结构，我们将每一个值存为区间右端点的一个“lowbit”长度的区间中，就构成了树状数组（真的是很粗。。。）</p>
<h2 id="细：简介"><a href="#细：简介" class="headerlink" title="细：简介"></a>细：简介</h2><p>首先，树状数组这个数据结构可以动态维护区间和，支持单点修改区间查询（其实还支持区间修改单点查询或者都一起支持，这个后续再讲，因为是扩展内容）<br>在学习快速幂算法的过程中，我们可以知道一个事实：<br>任意正整数都可以表示为2的整数次幂相加（也就是二进制分解）<br>那么，6=4+2（2^2+2^1），14=8+4+2（2^3+2^2+2^1）<br>那么我们可以将1<del>6这个区间表示为1</del>4并5<del>6（具体为什么不是1</del>2并3<del>6一会再说）<br>1</del>14可以表示为1<del>8并9</del>12并13~14<br>我们就可以进行存储。<br>那么。。。如何存储或查询呢？<br>6可以表示为（110）2,14可以表示为（1110）2，我们可以通过一个小操作实现取出110最右边（最小的）那个1，就是<strong>lowbit</strong>。</p>
<h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p>lowbit操作，涉及到了一些位运算的知识：<br>我们不妨设n&gt;0，n的第k位是1,0<del>k-1位是0（1000000……）<br>那么我们先将n取反，此时第k位变成了0，0</del>k-1都是1<br>我们再将n加上1，那么最后的那k位就变回了原来的样子<br>但是：第k+1位往后，就变成了与之前相反的数<br>我们可以想到按位and操作：只要有一个不是0，就把这一位变成0，都是1变成1<br>k+1位往后是都相反的，那说明那几位中按位and运算一定会全部变成0<br>第k位从始至终都是1,0<del>k-1位从始至终都是0<br>那么这个数只剩下了2^k-1<br>表示为：n&amp;(</del>n+1)<br>然而在补码的表示下，<del>n=-1-n，那么</del>n+1==-n<br>所以lowbit运算最后就变成了n&amp;-n</p>
<h2 id="查询和存储"><a href="#查询和存储" class="headerlink" title="查询和存储"></a>查询和存储</h2><h3 id="存储-或者说是单点修改"><a href="#存储-或者说是单点修改" class="headerlink" title="存储(或者说是单点修改)"></a>存储(或者说是单点修改)</h3><p>在讲完了lowbit操作之后，就到了实现<br>查询的时候，我们还是以n来举例子<br>我们想要存储1-n的前缀和，就是分步走<br>7存到t[7]之后<br>我们就需要修改它的父节点<br>通过lowbit操作我们可以知道，我们现在存储的节点的区间长度是lowbit(n)<br>我们想要到我们的父节点，父节点的区间长度应是我们的二倍(或者是和之前的进行拼接成为更大的区间)<br>所以我们应该让lowbit变大。<br>由我们的计算机存储方式二进制可以得到，lowbit的这一位加上1，会变成0，然而更高的哪一位会加一（直到不能进位）（两个同样长的挨着的区间分别存储是不优的，因为我们是在存储前缀和，直接详见可以得到答案就不需要浪费空间进行存储），这正好顺应了我们想要存区间的需求，那我们就让n加上lowbit（n）便是他的父节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x)</span><br><span class="line">        t[x] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>存储其实和查询有一点反操作的感觉<br>我们考虑一个区间1<del>7<br>7=(111)2<br>那么，我们就可以知道，sum（1</del>7）=sum（1-4）+sum(5-6)+sum(7);<br>我们进行7的存储，就可以分步走：<br>首先将sum（7）存储进sum（1-7），7-=1 现在为6<br>将sum（5-6）存进sum（1-7），6-=2 现在为4<br>再将sum（1-4）存进sum（1-7，4-=4 现在为0，结束<br>所以我们sum(n)存的区间的长度就可以是lowbit(n)<br>那样的话sum(n-lowbit(n))存的就是下一位（100000……）直到变成0<br>这就是树状数组的存储</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">        ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>洛谷P3374，P3368是模板题，可以去看看</p>
<h3 id="P1966-火柴排队-题目链接"><a href="#P1966-火柴排队-题目链接" class="headerlink" title="P1966 火柴排队 题目链接"></a>P1966 火柴排队 <a href="https://www.luogu.com.cn/problem/P1966">题目链接</a></h3><p>这道题倒是不难（我个人感觉应该到不了蓝色。。。）（我太菜了）<br>根据题目所说的是，两根火柴的距离定义为(a-b)^2，那么就让第i长的和第i长的放在一起，这样会是最小（贪心）<br>因为如果这样的话就相当于是火柴的对应关系固定的死死的，那么，我们就将火柴以编号命名（离散化但不完全离散化），然后求逆序对数<br>由于我们想让第1对应第1，就相当于a数组2 3 1 4，我将它变为2-&gt;1,3-&gt;2,1-&gt;3,4-&gt;4，序列变为1 2 3 4<br>然而b数组对应之后变成个1 4 2 3，就相当于是冒泡排序求最少交换多少次，这个次数就是序列的逆序对数<br>（所以我说很简单嘛）<br>（代码）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 99999997</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c1[maxn], c2[maxn];</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x)</span><br><span class="line">        t[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">        ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], c1[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; b[i], c2[i] = b[i];</span><br><span class="line">    <span class="built_in">sort</span>(c1 + <span class="number">1</span>, c1 + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">sort</span>(c2 + <span class="number">1</span>, c2 + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(c1 + <span class="number">1</span>, c1 + <span class="number">1</span> + n, a[i]) - c1;</span><br><span class="line">        b[i] = <span class="built_in">lower_bound</span>(c2 + <span class="number">1</span>, c2 + <span class="number">1</span> + n, b[i]) - c2;</span><br><span class="line">        q[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = q[a[i]];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">ask</span>(n) - <span class="built_in">ask</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5677-配对统计-题目链接"><a href="#P5677-配对统计-题目链接" class="headerlink" title="P5677 配对统计 题目链接"></a>P5677 配对统计 <a href="https://www.luogu.com.cn/problem/P5677">题目链接</a></h3><p>这道题，其实也不难，但是我想了很长时间<br>（其实就是理解错题意了。。。）<br>我们考虑首先对于好的配对进行预处理，求出每一组好的配对<br>然后进行记录。记录的过程中，我们可以将配对放在一个数组中。<br>配对分几种情况：<br>首先，如果说我们将序列上的所有数字放在一条数轴上，一个数字对应的好的配对一定在它的两侧，那么分三种情况：<br>左边距离小，右边距离小，两边一样<br>就可以进行处理。两边一样的就有两组好的配对是当前数字的。<br>我们处理完配对之后，将它们在存储时改为左端点右端点单增（我只需要统计个数又不统计在哪）<br>我们对配对排序（以右端点升序排序），再将询问进行升序排序（同样是右端点）<br>我们枚举每一个询问，将右端点比询问的右端点小的配对的左端点放入树状数组（很绕口—）<br>我们统计左端点在l<del>r区间之内的个数，就是配对在l</del>r区间的个数（右端点比询问的右端点小，比自己的左端点大，所以只要我的左端点大于询问的左端点就可以是一个配对了）<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 600010</span></span><br><span class="line"><span class="keyword">int</span> n, m, t[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">no</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> q1, q2, pos;</span><br><span class="line">&#125; question[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qcmp</span><span class="params">(no x, no y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.q2 == y.q2)</span><br><span class="line">        <span class="keyword">return</span> x.q1 &lt; y.q1;</span><br><span class="line">    <span class="keyword">return</span> x.q2 &lt; y.q2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= n)</span><br><span class="line">        t[pos]++, pos += (pos &amp; -pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        sum += t[num], num -= (num &amp; -num);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num, pos;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.num &lt; y.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addq</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[++cnt].first = <span class="built_in">min</span>(x, y);</span><br><span class="line">    q[cnt].second = <span class="built_in">max</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.second == y.second)</span><br><span class="line">        <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i].num, a[i].pos = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="built_in">addq</span>(a[<span class="number">1</span>].pos, a[<span class="number">2</span>].pos);</span><br><span class="line">    <span class="built_in">addq</span>(a[n].pos, a[n - <span class="number">1</span>].pos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].num - a[i - <span class="number">1</span>].num &lt; a[i + <span class="number">1</span>].num - a[i].num)</span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i - <span class="number">1</span>].pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i].num - a[i - <span class="number">1</span>].num == a[i + <span class="number">1</span>].num - a[i].num)</span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i - <span class="number">1</span>].pos), <span class="built_in">addq</span>(a[i].pos, a[i + <span class="number">1</span>].pos);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">addq</span>(a[i].pos, a[i + <span class="number">1</span>].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + cnt, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; question[i].q1 &gt;&gt; question[i].q2, question[i].pos = i;</span><br><span class="line">    <span class="built_in">sort</span>(question + <span class="number">1</span>, question + <span class="number">1</span> + m, qcmp);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q[j].second &lt;= question[i].q2 &amp;&amp; j &lt;= cnt)</span><br><span class="line">             <span class="built_in">add</span>(q[j].first),j++;</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)(j - <span class="number">1</span> - <span class="built_in">ask</span>(question[i].q1 - <span class="number">1</span>)) * question[i].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树状数组结束-完结撒花"><a href="#树状数组结束-完结撒花" class="headerlink" title="树状数组结束 完结撒花"></a>树状数组结束 完结撒花</h1>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="一个可以累死人的数据结构"><a href="#一个可以累死人的数据结构" class="headerlink" title="一个可以累死人的数据结构"></a>一个可以累死人的数据结构</h1><h1 id="线段树（仅限于基础的那个）（zx树这种的以后再说）"><a href="#线段树（仅限于基础的那个）（zx树这种的以后再说）" class="headerlink" title="线段树（仅限于基础的那个）（zx树这种的以后再说）"></a>线段树（仅限于基础的那个）（zx树这种的以后再说）</h1><p>线段树是一个神奇的数据结构，他基本上什么区间操作都可以优化<br>这里讲一些基本的操作：单点修改，区间查询，区间修改（延迟标记）</p>
<h2 id="首先讲……概念…-我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点"><a href="#首先讲……概念…-我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点" class="headerlink" title="首先讲……概念…(我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点)"></a>首先讲……概念…(我的线段树写的有的不一样，有的是用结构体存的左右节点，有的是在函数定义上存的节点)</h2><p>线段树，顾名思义，一个树形结构，存储的每一个节点都是一个线段<br>线段树的根节点存储着区间1-n的总信息，2号存1-（1+n）/2。。。<br>每一个线段的子节点都是自己线段的两半，直到叶子结点l==r</p>
<h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p>我们在进行单点修改的过程中，一般指令都是这个样子：c x y，表示操作a[x]=y；<br>我们可以知道，线段树维护的是一条线段，只有叶子结点维护的是点，那么，我们首先应该递归到叶子结点，然后修改值，再向上修改父节点，就以区间和为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r&amp;&amp;l==x)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p]=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(p*<span class="number">2</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    t[p]=t[p*<span class="number">2</span>]+t[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>我们查询一个区间的时候，绝对不可能只是查询一个节点，基本上每一次都会查询到多个节点，那么我们应该怎么实现呢<br>操作1：首先一个区间l-r，我们可能需要查询的区间为x1-x2,x2-x3,x3-x4<br>首先，如果我们递归到了当前的节点，这个节点的线段是被我们查询的这个区间所覆盖住的，我们直接把这个节点统计到答案之中，应为我们可以分成若干个线段树的节点，所以只要我们一直递归，就一定可以地轨道两个节点，l-x5,x6-r，这之间的所有节点都是被我们操作1所统计的，所以直接把这个答案返回。<br>如果不懂可以自己手模一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l &amp;&amp; y&gt;=r) <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改（懒标记laztag）"><a href="#区间修改（懒标记laztag）" class="headerlink" title="区间修改（懒标记laztag）"></a>区间修改（懒标记laztag）</h2><p>这是一大难点啊。。。<br>首先对于我们上面的区间查询，我们可以感受到，线段树在对我们的区间进行一定的操作时，是可以划分为不同的节点进行操作的，那么，区间修改是否也可以这么做呢？<br>答案是肯定的<br>区间修改，在又一次经过操作1之后，我们就可以改变已经被覆盖的区间，比如区间和，我们就直接让这个区间增加x*len(长度)，然后return<br>可是这样并不满足我们的需要，因为区间修改的时候这样修改的确会直接将上面的数据进行修改，但是，我们如果多次操作，修改的次数一多，查询有交集的区间就会受影响，因此，我们引入懒标记：<br>懒标记是标记我们当前的节点需要进行区间修改，还是区间和为例，我们laz[x]就代表着x节点的线段中每一个数都需要增加laz[x]这么多，只要我们每一次在进行区间统计师，都将我们的父节点的laztag传下来，我们就知道，从最开始到现在，我们没、每一个节点总共需要至少增加多少(我说至少是因为当前节点的子节点(或者是子孙节点)可能laztag非零)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p*<span class="number">2</span>].pre+=t[p].add*(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>);</span><br><span class="line">        t[p*<span class="number">2</span>+<span class="number">1</span>].pre+=t[p].add*(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">        t[p*<span class="number">2</span>].add+=t[p].add;</span><br><span class="line">        t[p*<span class="number">2</span>+<span class="number">1</span>].add+=t[p].add;</span><br><span class="line">        t[p].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=t[p].l &amp;&amp; y&gt;=t[p].r)&#123;</span><br><span class="line">        t[p].pre+=(<span class="keyword">long</span> <span class="keyword">long</span>)z*(t[p].r-t[p].l+<span class="number">1</span>);</span><br><span class="line">        t[p].add+=z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid=t[p].l+t[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre=t[p*<span class="number">2</span>].pre+t[p*<span class="number">2</span>+<span class="number">1</span>].pre;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这玩意的例题可多可难。。。这几个题我都至少调了有2hours</p>
<h3 id="P2471-降雨量-题目链接"><a href="#P2471-降雨量-题目链接" class="headerlink" title="P2471 降雨量 题目链接"></a>P2471 降雨量 <a href="https://www.luogu.com.cn/problem/P2471">题目链接</a></h3><p>这道题真的不错(难调)<br>首先这道题需要进行分类讨论：<br>对于我们查询的区间(l,r)<br>我们先判断false：<br>1.左端点年份确定了，右端点年份不确定，那我们的中间的最大值大于左端点（我们的定义应该是左端点的降雨量比右端点大并且右端点比一整个区间之内别的都大，所以中间最大值大于左端点就不成立）<br>2.右端点年份确定，左端点不确定，那么中间的最大值大于右端点，同样不成立<br>3.都确定了，左端点小于右端点<br>然后是maybe：<br>1.年份不连续：右端点减去左端点和左右端点年分之差不相等<br>2.左端点不确定<br>3.右端点不确定<br>（由于我们已经切掉了false的情况，所以只剩下了maybe和true，而有任何一个不确定都不可能是true，所以。。。直接扔掉）<br>只要不是FALSE或者是maybe那就是true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400010</span></span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt] = b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (a[mid + <span class="number">1</span>] - a[mid] &gt; <span class="number">1</span> || c[rt * <span class="number">2</span>] || c[rt * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">        c[rt] = <span class="number">1</span>;</span><br><span class="line">    t[rt] = <span class="built_in">max</span>(t[rt * <span class="number">2</span>], t[rt * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; y &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(rt * <span class="number">2</span>, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">ask</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx, yy;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        <span class="keyword">if</span> (xx &gt;= yy)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, xx) - a;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, yy) - a;</span><br><span class="line">        <span class="keyword">int</span> mm =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[x]!=xx)x--;</span><br><span class="line">        <span class="keyword">if</span>(x+<span class="number">1</span>&lt;=y<span class="number">-1</span>)mm= <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((a[y]==yy&amp;&amp;mm&gt;=b[y])||(a[x]==xx&amp;&amp;mm&gt;=b[x])||(a[y]==yy&amp;&amp;a[x]==xx&amp;&amp;b[x]&lt;b[y]))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - x != a[y] - a[x] || a[x] != xx || a[y] != yy)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;maybe&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5490-扫描线（也是lyd例题）题目链接"><a href="#P5490-扫描线（也是lyd例题）题目链接" class="headerlink" title="P5490 扫描线（也是lyd例题）题目链接"></a>P5490 扫描线（也是lyd例题）<a href="https://www.luogu.com.cn/problem/P5490">题目链接</a></h3><p>扫描线是一个非常经典的算法，可以用来求面积和，周长并等<br>以面积和为例：<br>我们放进坐标系中几个矩形，我们想要求出它们的面积和，第一可以想到用容斥原理，但他很慢。。。<br>我们考虑这么一件事情，我们假设有一条平行于纵轴的直线，他在随便移动。<br>对于我们矩形放在一起之后的形状，我们可以把这个图形分割成很多个小的没有交集的矩形<br>所以，我们可以把这条线进行左右移动，每次线和图形相交的地方是一定的，并且都是矩形，所以线的长度会有最多2n个，用这2n条线长度乘上横坐标的距离（矩形的宽度），就可以把我们的总面积求出来咯</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1&lt;&lt;21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sline</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,h,l,k;</span><br><span class="line">&#125;line[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">setree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,cnt,len;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt].l=l;t[rt].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(t[rt].l+t[rt].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> rk[maxn],val[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(sline mm,sline nn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mm.x&lt;nn.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].cnt)t[rt].len=val[t[rt].r+<span class="number">1</span>]-val[t[rt].l];</span><br><span class="line">    <span class="keyword">else</span> t[rt].len=t[ls].len+t[rs].len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[rt].l&amp;&amp;r&gt;=t[rt].r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt].cnt+=v;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(t[rt].l+t[rt].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(ls,l,r,v);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(rs,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx,x_x,yy,y_y,m=i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        cin&gt;&gt;xx&gt;&gt;yy&gt;&gt;x_x&gt;&gt;y_y;</span><br><span class="line">        line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].x = xx, line[i &lt;&lt; <span class="number">1</span>].x = x_x;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].h = line[i &lt;&lt; <span class="number">1</span>].h = y_y;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].l = line[i &lt;&lt; <span class="number">1</span>].l = yy;</span><br><span class="line">		line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>].k = <span class="number">1</span>, line[i &lt;&lt; <span class="number">1</span>].k = <span class="number">-1</span>;</span><br><span class="line">        rk[++cnt]=yy;</span><br><span class="line">        rk[++cnt]=y_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(rk+<span class="number">1</span>,rk+<span class="number">2</span>*n+<span class="number">1</span>);    </span><br><span class="line">    cnt=<span class="built_in">unique</span>(rk+<span class="number">1</span>,rk+<span class="number">2</span>*n+<span class="number">1</span>)-rk<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1=<span class="built_in">lower_bound</span>(rk+<span class="number">1</span>,rk+<span class="number">1</span>+cnt,line[i].h)-rk;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="built_in">lower_bound</span>(rk+<span class="number">1</span>,rk+<span class="number">1</span>+cnt,line[i].l)-rk;</span><br><span class="line">        val[p1]=line[i].h;</span><br><span class="line">        val[p2]=line[i].l;</span><br><span class="line">        line[i].h=p1;</span><br><span class="line">        line[i].l=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(line+<span class="number">1</span>,line+<span class="number">1</span>+<span class="number">2</span>*n,cmp);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,line[i].l,line[i].h<span class="number">-1</span>,line[i].k);</span><br><span class="line">        ans+=t[<span class="number">1</span>].len*(line[i+<span class="number">1</span>].x-line[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有另一道题使用到了扫描线算法的（太累了不想写）<br>P1502 窗口的星星</p>
<h3 id="P4198-楼房重建题目链接"><a href="#P4198-楼房重建题目链接" class="headerlink" title="P4198 楼房重建题目链接"></a>P4198 楼房重建<a href="https://www.luogu.com.cn/problem/P4198">题目链接</a></h3><p>这道题是真的。。。很好。。。<br>首先很容易想到的是每一个数我们可以通过求斜率来判断是否能看见这栋楼<br>我们考虑答案，就是1-n这个区间之内，求单增的斜率个数最长递增的斜率<br>因为我们的区间是固定的，我们可以通过将区间分为两半进行处理，就可以想到使用线段树<br>线段树中维护两个信息：区间最大值和区间单增斜率数量<br>build,pushdown都不需要。。。但是pushup操作就很烦。。。<br>最大值的pushup是很简单的，两个区间的最大值嘛<br>可是单增斜率数量是个很棘手的东西:<br>我们设lx为我pushup进这个大区间里，必须大于的最小值<br>先说边界：<br>如果l==r那numk[rt]=a[l]&gt;lx;如果只有一个元素，那么我如果递归的原来区间的最左端是比它大于等于的，那numk[rt]=0，否则等于1（显然）<br>对于我需要pushup的区间，左半边区间可以直接pushup上去，没影响，右半边要考虑和左半边儿子的关系，lx便是左区间的最大值<br>考虑右儿子的左右两个子区间：<br>设s1为左区间s2为右区间<br>1.如果s1的最大值小于等于lx直接舍去递归s2<br>2.如果s1的最大值大于lx那么我的s2里原本看不看得见的直接pushup上去就可以，然而右半区间的看得见的应该是numk[rk]-num[rk<em>2]而不是numk[rk</em>2+1]因为右半区间有的是不能上去的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500010</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> nk[maxn];</span><br><span class="line"><span class="keyword">double</span> t[maxn], lv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushup</span><span class="params">(<span class="keyword">double</span> lx, <span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[rt] &lt;= lx)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lv[l] &gt; lx)</span><br><span class="line">        <span class="keyword">return</span> nk[rt];</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t[rt * <span class="number">2</span>] &lt;= lx)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pushup</span>(lx, rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pushup</span>(lx, rt * <span class="number">2</span>, l, mid) + nk[rt] - nk[rt * <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r &amp;&amp; r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt] = (<span class="keyword">double</span>)y/x;</span><br><span class="line">        nk[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">change</span>(rt * <span class="number">2</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">change</span>(rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    t[rt] = <span class="built_in">max</span>(t[rt * <span class="number">2</span>], t[rt * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    nk[rt] = <span class="built_in">pushup</span>(t[rt * <span class="number">2</span>], rt * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r) + nk[rt * <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        lv[x[i]] = (<span class="keyword">double</span>)y[i] / x[i];</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, x[i], y[i]);</span><br><span class="line">        cout &lt;&lt; nk[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="撒花-完结-（终于-写完了）"><a href="#撒花-完结-（终于-写完了）" class="headerlink" title="撒花 完结 （终于**写完了）"></a>撒花 完结 （终于**写完了）</h1>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
